<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi,ghostsf</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ghostsf.com/"/>
  <updated>2020-03-08T09:47:34.599Z</updated>
  <id>https://ghostsf.com/</id>
  
  <author>
    <name>ghostsf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何学习新技术？</title>
    <link href="https://ghostsf.com/how2learn/"/>
    <id>https://ghostsf.com/how2learn/</id>
    <published>2020-03-06T16:37:08.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/post/how2learn.png" alt="如何学习新技术"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/post/how2learn.png&quot; alt=&quot;如何学习新技术&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="学习" scheme="https://ghostsf.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>简单且高度可扩展的分布式文件系统SeaweedFS，看这一篇就够了</title>
    <link href="https://ghostsf.com/seaweedfs/"/>
    <id>https://ghostsf.com/seaweedfs/</id>
    <published>2020-03-06T16:08:21.000Z</published>
    <updated>2020-03-08T09:47:34.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p><img src="https://raw.githubusercontent.com/chrislusf/seaweedfs/master/note/seaweedfs.png" alt="SeaweedFS Logo"></p><p>Github: <a href="https://github.com/chrislusf/seaweedfs" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs</a></p><p><a href="https://travis-ci.org/chrislusf/seaweedfs" target="_blank" rel="noopener"><img src="https://travis-ci.org/chrislusf/seaweedfs.svg?branch=master" alt="Build Status"></a><br><a href="https://godoc.org/github.com/chrislusf/seaweedfs/weed" target="_blank" rel="noopener"><img src="https://godoc.org/github.com/chrislusf/seaweedfs/weed?status.svg" alt="GoDoc"></a><br><a href="https://github.com/chrislusf/seaweedfs/wiki" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/docs-wiki-blue.svg" alt="Wiki"></a><br><a href="https://hub.docker.com/r/chrislusf/seaweedfs/" target="_blank" rel="noopener"><img src="https://img.shields.io/docker/pulls/chrislusf/seaweedfs.svg?maxAge=604800" alt="Docker Pulls"></a></p><blockquote><p>SeaweedFS is a simple and highly scalable distributed file system, to store and serve billions of files fast! SeaweedFS implements an object store with O(1) disk seek, transparent cloud integration, and an optional Filer with POSIX interface, supporting S3 API, Rack-Aware Erasure Coding for warm storage, FUSE mount, Hadoop compatible, WebDAV.</p></blockquote><p>SeaweedFS是一个简单且高度可扩展的分布式文件系统，可以快速存储和提供数十亿个文件！SeaweedFS通过 O(1) 磁盘搜索，透明云集成以及带有POSIX接口的可选Filer，实现了对象存储，支持S3 API，用于热存储的机架感知擦除编码，FUSE安装，Hadoop兼容，WebDAV。</p><a id="more"></a><h1 id="0x01-基础概念"><a href="#0x01-基础概念" class="headerlink" title="0x01 基础概念"></a>0x01 基础概念</h1><p>随着业务量增长，一个系统需要存储上百万文件的情况越来越多，尤其是互联网网站。在这种情况下依然使用传统磁盘/共享存储的方式进行支持会有以下问题：</p><ul><li><p>文件的备份、恢复困难，大量文件的copy 耗时耗力</p></li><li><p>文件数量暴增占满操作系统文件系统inode，导致磁盘空间虽然没有用完但是因为inode用尽无法使用</p></li><li><p>文件读取效率太低，无法应对高并发读取要求<br>针对以上问题，facebook 提出了自己的方案 <a href="http://www.usenix.org/event/osdi10/tech/full_papers/Beaver.pdf" target="_blank" rel="noopener">Facebook’s Haystack design paper</a> 。 之后各种实现出现，如tfs、MogileFS、GlusterFS等，其中Seaweedfs是一个比较优秀的实现。具有效率高、结构简单、代码清晰等优点。</p></li></ul><p>在逻辑上Seaweedfs的几个概念：</p><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>Node</td><td>系统抽象的节点，抽象为DataCenter、Rack、DataNode</td></tr><tr><td>DataCenter</td><td>数据中心，对应现实中的不同机房</td></tr><tr><td>Rack</td><td>机架，对应现实中的机柜</td></tr><tr><td>Datanode</td><td>存储节点，用于管理、存储逻辑卷，其实就是Volume server（卷服务器），而Volume server下是有很多个逻辑卷的</td></tr><tr><td>Volume</td><td>逻辑卷，存储的逻辑结构，逻辑卷下存储Needle</td></tr><tr><td>Needle</td><td>逻辑卷中的Object，对应存储的文件（每个文件有一个唯一needleID）</td></tr><tr><td>Collection</td><td>文件集，可以分布在多个逻辑卷上</td></tr></tbody></table><p><strong>结构说明</strong>：<br><img src="/images/post/seaweed1.png" alt="结构说明"></p><h1 id="0x02-组成部分"><a href="#0x02-组成部分" class="headerlink" title="0x02 组成部分"></a>0x02 组成部分</h1><ol><li><p>基础部分：Master server + Volume server</p></li><li><p>扩展部分：Filer server + Cronjob server (Replication-job) + S3 server</p><blockquote><p>值得注意的一点：外部与 Master Server、Volume Server 和 Filer 进行通信的方式是 HTTP API。API的用法官网有<a href="https://github.com/chrislusf/seaweedfs/wiki/Master-Server-API" target="_blank" rel="noopener">详细说明</a>。</p></blockquote></li></ol><p><strong>部署结构</strong>：<br><img src="/images/post/seaweed2.png" alt="部署说明"></p><h1 id="0x03-快速上手"><a href="#0x03-快速上手" class="headerlink" title="0x03 快速上手"></a>0x03 快速上手</h1><p>从 <a href="https://github.com/chrislusf/seaweedfs/releases" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/releases</a> 下载最新版本</p><p>解压缩下载的文件，只会找到一个可执行文件，在大多数系统上是“ weed”，在Windows上是“ weed.exe”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed -h # to check available options</span><br></pre></td></tr></table></figure><h2 id="配置运行Weed-Master-server"><a href="#配置运行Weed-Master-server" class="headerlink" title="配置运行Weed Master server"></a>配置运行Weed Master server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed master -h # to check available options</span><br></pre></td></tr></table></figure><p>如果不需要复制，就足够了。<code>mdir</code>选项用于配置保存生成的序列文件ID的文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./weed master -mdir="."</span><br><span class="line">./weed master -mdir="." -ip=xxx.xxx.xxx.xxx # usually set the ip instead the default "localhost"</span><br></pre></td></tr></table></figure><h2 id="配置运行Weed-Volume-Server"><a href="#配置运行Weed-Volume-Server" class="headerlink" title="配置运行Weed Volume Server"></a>配置运行Weed Volume Server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed volume -h # to check available options</span><br></pre></td></tr></table></figure><p>通常，卷服务器分布在不同的服务器上。它们可以具有不同的磁盘空间，甚至可以具有不同的操作系统。</p><p>通常，你需要指定可用磁盘空间，Weed Master地址和存储文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed volume -max=100 -mserver="localhost:9333" -dir="./data"</span><br></pre></td></tr></table></figure><p><strong>PS</strong>：设置一台Weed Master server和一台Weed Volume Server，可以用weed server简写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./weed server -dir="./data"</span><br><span class="line"><span class="meta">#</span><span class="bash"> same, just specifying the default values</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> use <span class="string">"weed server -h"</span> to find out more</span></span><br><span class="line">./weed server -master.port=9333 -volume.port=8080 -dir="./data"</span><br></pre></td></tr></table></figure><h2 id="测试SeaweedFS"><a href="#测试SeaweedFS" class="headerlink" title="测试SeaweedFS"></a>测试SeaweedFS</h2><p>随着主服务器和卷服务器的启动，现在呢？让我们将大量文件注入系统！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed upload -dir="/some/big/folder"</span><br></pre></td></tr></table></figure><p>此命令将以递归方式上载所有文件。或者，您可以指定要包括的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed upload -dir="/some/big/folder" -include=*.txt</span><br></pre></td></tr></table></figure><p>然后，您只需检查“ du -m -s / some / big / folder”即可查看操作系统的实际磁盘使用情况，并将其与“ / data”下的文件大小进行比较。通常，如果您要上传大量文本文件，则消耗的磁盘大小会小得多，因为文本文件会自动压缩。</p><h1 id="0x04-在docker中使用"><a href="#0x04-在docker中使用" class="headerlink" title="0x04 在docker中使用"></a>0x04 在docker中使用</h1><p>与docker一起使用很容易，因为它在本地运行，您可以像上面那样传递所有args。但是您不必担心“ -ip”。入口点脚本将对其进行处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9333:9333 --name master chrislusf/seaweedfs master -ip=master</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -p 18080:18080 --name volume --link master chrislusf/seaweedfs volume -max=5 -mserver="master:9333" -port=8080</span><br></pre></td></tr></table></figure><h2 id="使用compose"><a href="#使用compose" class="headerlink" title="使用compose"></a>使用compose</h2><p>但是使用Compose最简单。要启动，只需运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker/seaweedfs-compose.yml -p seaweedfs up</span><br></pre></td></tr></table></figure><p>您可以使用映像“ chrislusf / seaweedfs”或在根目录中使用dockerfile构建自己的映像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name weed chrislusf/seaweedfs server</span><br></pre></td></tr></table></figure><h2 id="从dockerfile构建image"><a href="#从dockerfile构建image" class="headerlink" title="从dockerfile构建image"></a>从dockerfile构建image</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/chrislusf/seaweedfs.git</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t 'chrislusf/seaweedfs' .</span><br></pre></td></tr></table></figure><h2 id="构建docker-image"><a href="#构建docker-image" class="headerlink" title="构建docker image"></a>构建docker image</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv Dockerfile Dockerfile.minimal</span><br><span class="line">mv Dockerfile.go_build Dockerfile</span><br><span class="line">docker build --no-cache -t 'chrislusf/seaweedfs' .</span><br></pre></td></tr></table></figure><h2 id="生产使用"><a href="#生产使用" class="headerlink" title="生产使用"></a>生产使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> start our weed server daemonized</span></span><br><span class="line">docker run --name weed -d -p 9333:9333 -p 8080:8080 -p 18080:8080 \</span><br><span class="line">  -v /opt/weedfs/data:/data chrislusf/seaweedfs server -dir="/data" \ </span><br><span class="line">  -publicIp="$(curl -s cydev.ru/ip)"</span><br></pre></td></tr></table></figure><p>现在，SeaweedFS服务器将是持久性的，并且可以通过主机上的localhost：9333，：8080和：18080进行访问。不要忘记为指定正确的“ -publicIp”。</p><h1 id="0x05-组成部分介绍"><a href="#0x05-组成部分介绍" class="headerlink" title="0x05 组成部分介绍"></a>0x05 组成部分介绍</h1><h2 id="Master-Server"><a href="#Master-Server" class="headerlink" title="Master Server"></a>Master Server</h2><blockquote><p>Master是不存储数据的，只做集群协调，类似于Zookeeper的作用。</p></blockquote><p>Master Server API 详见 <a href="https://github.com/chrislusf/seaweedfs/wiki/Master-Server-API" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Master-Server-API</a></p><p><strong>Tips</strong>：可以使用＆pretty = y附加到任何HTTP API，以查看格式化的json输出。</p><h3 id="分配一个fileId，用于接下来的存储文件"><a href="#分配一个fileId，用于接下来的存储文件" class="headerlink" title="分配一个fileId，用于接下来的存储文件"></a>分配一个fileId，用于接下来的存储文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Basic Usage:</span></span><br><span class="line">curl http://localhost:9333/dir/assign</span><br><span class="line">&#123;"count":1,"fid":"3,01637037d6","url":"127.0.0.1:8080",</span><br><span class="line"> "publicUrl":"localhost:8080"&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> To assign with a specific replication <span class="built_in">type</span>:</span></span><br><span class="line">curl "http://localhost:9333/dir/assign?replication=001"</span><br><span class="line"><span class="meta">#</span><span class="bash"> To specify how many file ids to reserve</span></span><br><span class="line">curl "http://localhost:9333/dir/assign?count=5"</span><br><span class="line"><span class="meta">#</span><span class="bash"> To assign a specific data center</span></span><br><span class="line">curl "http://localhost:9333/dir/assign?dataCenter=dc1"</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:9333/dir/lookup?volumeId=3&amp;pretty=y"</span><br><span class="line">&#123;</span><br><span class="line">  "locations": [</span><br><span class="line">    &#123;</span><br><span class="line">      "publicUrl": "localhost:8080",</span><br><span class="line">      "url": "localhost:8080"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Other usages:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can actually use the file id to lookup, <span class="keyword">if</span> you are lazy to parse the file id.</span></span><br><span class="line">curl "http://localhost:9333/dir/lookup?volumeId=3,01637037d6"</span><br><span class="line"><span class="meta">#</span><span class="bash"> If you know the collection, specify it since it will be a little faster</span></span><br><span class="line">curl "http://localhost:9333/dir/lookup?volumeId=3&amp;collection=turbo"</span><br></pre></td></tr></table></figure><h3 id="强制垃圾收集"><a href="#强制垃圾收集" class="headerlink" title="强制垃圾收集"></a>强制垃圾收集</h3><p>如果您的系统有许多删除操作，则不会同步回收已删除文件的磁盘空间。有一个后台作业可检查卷磁盘使用情况。如果空白空间大于阈值（默认值为0.3），真空作业将使该卷成为只读卷，仅使用现有文件创建一个新卷，然后打开新卷。如果嫌麻烦或正在做一些测试，请用这种方法清理未使用的空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:9333/vol/vacuum"</span><br><span class="line">curl "http://localhost:9333/vol/vacuum?garbageThreshold=0.4"</span><br></pre></td></tr></table></figure><p>garbageThreshold = 0.4是可选的，并且不会更改默认阈值。您可以使用不同的默认垃圾阈值启动卷主机。此操作并非易事。它将尝试制作.dat和.idx文件的副本，跳过已删除的文件，并切换到新文件，删除旧文件。</p><h3 id="预分配卷"><a href="#预分配卷" class="headerlink" title="预分配卷"></a>预分配卷</h3><p>一个卷服务一次写入。如果需要增加并发性，则可以预分配大量卷。这是例子。也可以组合所有不同的选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> specify a specific replication</span></span><br><span class="line">curl "http://localhost:9333/vol/grow?replication=000&amp;count=4"</span><br><span class="line">&#123;"count":4&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> specify a collection</span></span><br><span class="line">curl "http://localhost:9333/vol/grow?collection=turbo&amp;count=4"</span><br><span class="line"><span class="meta">#</span><span class="bash"> specify data center</span></span><br><span class="line">curl "http://localhost:9333/vol/grow?dataCenter=dc1&amp;count=4"</span><br><span class="line"><span class="meta">#</span><span class="bash"> specify ttl</span></span><br><span class="line">curl "http://localhost:9333/vol/grow?ttl=5d&amp;count=4"</span><br></pre></td></tr></table></figure><p>这将生成4个空卷。</p><h3 id="删除文件集"><a href="#删除文件集" class="headerlink" title="删除文件集"></a>删除文件集</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> delete a collection</span></span><br><span class="line">curl "http://localhost:9333/col/delete?collection=benchmark&amp;pretty=y"</span><br></pre></td></tr></table></figure><h3 id="检查系统状态"><a href="#检查系统状态" class="headerlink" title="检查系统状态"></a>检查系统状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "http://10.0.2.15:9333/cluster/status?pretty=y"</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:9333/dir/status?pretty=y"</span><br></pre></td></tr></table></figure><h2 id="Volume-Server"><a href="#Volume-Server" class="headerlink" title="Volume Server"></a>Volume Server</h2><blockquote><p>这个就是所谓的“Data Node”数据节点，用于挂载磁盘存储文件。Volume Server与Master Server通信，受Master控制。可以动态的增加和减少VolumeServer，这一点比另一个云存储MinIO要强得多。</p></blockquote><p>Volume Server API 可详见 <a href="https://github.com/chrislusf/seaweedfs/wiki/Volume-Server-API" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Volume-Server-API</a></p><p><strong>Tips</strong>：可以使用＆pretty = y附加到任何HTTP API，以查看格式化的json输出。</p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -F file=@/home/ghostsf/myphoto.jpg http://127.0.0.1:8080/3,01637037d6</span><br><span class="line">&#123;"size": 43234&#125;</span><br></pre></td></tr></table></figure><p>返回的大小是存储在SeaweedFS上的大小，有时文件会根据mime类型自动压缩。</p><h3 id="直接上传文件"><a href="#直接上传文件" class="headerlink" title="直接上传文件"></a>直接上传文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -F file=@/home/ghostsf/myphoto.jpg http://localhost:9333/submit</span><br><span class="line">&#123;"fid":"3,01fbe0dc6f1f38","fileName":"myphoto.jpg","fileUrl":"localhost:8080/3,01fbe0dc6f1f38","size":68231&#125;</span><br></pre></td></tr></table></figure><p>这个API只是为了方便。主服务器将获得一个文件id并将文件存储到正确的卷服务器。这是一个很方便的API，在分配文件id时不支持不同的参数。</p><h3 id="访问文件"><a href="#访问文件" class="headerlink" title="访问文件"></a>访问文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/3,01637037d6</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE http://127.0.0.1:8080/3,01637037d6</span><br></pre></td></tr></table></figure><h3 id="查看分块大文件的清单文件内容"><a href="#查看分块大文件的清单文件内容" class="headerlink" title="查看分块大文件的清单文件内容"></a>查看分块大文件的清单文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/3,01637037d6?cm=false</span><br></pre></td></tr></table></figure><h3 id="检查卷服务器状态"><a href="#检查卷服务器状态" class="headerlink" title="检查卷服务器状态"></a>检查卷服务器状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:8080/status?pretty=y"</span><br></pre></td></tr></table></figure><h2 id="Filer-Server"><a href="#Filer-Server" class="headerlink" title="Filer Server"></a>Filer Server</h2><p>文件管理器（Filer）可以用来 浏览文件和目录，以及add/delete files, and even browse the sub directories and files，还有检索、重命名等。</p><h3 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h3><p>将filer.toml文件添加到当前目录，或$ HOME / .seaweedfs / 或 / etc / seaweedfs /filer.toml</p><p>可以通过以下方式生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weed scaffold -config=filer -output="."</span><br></pre></td></tr></table></figure><p>查看的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weed scaffold -config=filer</span><br></pre></td></tr></table></figure><p>filer.toml文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[leveldb]</span><br><span class="line">enabled = true</span><br><span class="line">dir = "."# directory to store level db files</span><br></pre></td></tr></table></figure><p>两种方式启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> assuming you already started weed master and weed volume</span></span><br><span class="line">weed filer</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Or assuming you have nothing started yet,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this <span class="built_in">command</span> starts master server, volume server, and filer <span class="keyword">in</span> one shot. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It<span class="string">'s strictly the same as starting them separately.</span></span></span><br><span class="line">weed server -filer=true</span><br></pre></td></tr></table></figure><h3 id="管理文件"><a href="#管理文件" class="headerlink" title="管理文件"></a>管理文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Basic Usage:</span></span><br><span class="line">//create or overwrite the file, the directories /path/to will be automatically created</span><br><span class="line">POST /path/to/file</span><br><span class="line">//get the file content</span><br><span class="line">GET /path/to/file</span><br><span class="line">//create or overwrite the file, the filename in the multipart request will be used</span><br><span class="line">POST /path/to/</span><br><span class="line">//return a json format subdirectory and files listing</span><br><span class="line">GET /path/to/</span><br><span class="line">        Accept: application/json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> options <span class="keyword">for</span> POST a file:</span></span><br><span class="line">// set file TTL for Cassandra or Redis filer store.</span><br><span class="line">POST /path/to/file?ttl=1d</span><br><span class="line">// set file mode when creating or overwriting a file</span><br><span class="line">POST /path/to/file?mode=0755</span><br></pre></td></tr></table></figure><h3 id="列出目录下的文件"><a href="#列出目录下的文件" class="headerlink" title="列出目录下的文件"></a>列出目录下的文件</h3><p>这仅适用于嵌入式文件管理器。</p><p>一些文件夹可能非常大。为了有效地列出文件，我们使用非传统方式来迭代文件。每个分页都提供一个“ lastFileName”和一个“ limit = x”。文件管理器在O（log（n））时间中找到“ lastFileName”，并检索接下来的x个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List files under a directory</span><br><span class="line">This is for embedded filer only.</span><br><span class="line"></span><br><span class="line">Some folder can be very large. To efficiently list files, we use a non-traditional way to iterate files. Every pagination you provide a "lastFileName", and a "limit=x". The filer locate the "lastFileName" in O(log(n)) time, and retrieve the next x files.</span><br><span class="line"></span><br><span class="line">curl  "http://localhost:8888/javascript/?pretty=y&amp;lastFileName=new_name.js&amp;limit=2"</span><br><span class="line">&#123;</span><br><span class="line">  "Directory": "/javascript/",</span><br><span class="line">  "Files": [</span><br><span class="line">    &#123;</span><br><span class="line">      "name": "report.js",</span><br><span class="line">      "fid": "7,0254f1f3fd"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除文件-1"><a href="#删除文件-1" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X DELETE http://localhost:8888/path/to/file</span></span><br></pre></td></tr></table></figure><h4 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// recursively delete all files and folders under a path</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X DELETE http://localhost:8888/path/to/dir?recursive=<span class="literal">true</span></span></span><br><span class="line">// recursively delete everything, ignoring any recursive error</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X DELETE http://localhost:8888/path/to/dir?recursive=<span class="literal">true</span>&amp;ignoreRecursiveError=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line">// For Experts Only: remove filer directories only, without removing data chunks. </span><br><span class="line">// see https://github.com/chrislusf/seaweedfs/pull/1153</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X DELETE http://localhost:8888/path/to?recursive=<span class="literal">true</span>&amp;skipChunkDeletion=<span class="literal">true</span></span></span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>Filer具有连接到Master的持久客户端，以获取所有卷的位置更新。没有回调来查找卷ID位置。官方说明参见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Directories-and-Files#architecture" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Directories-and-Files#architecture</a></p><h3 id="mount挂载"><a href="#mount挂载" class="headerlink" title="mount挂载"></a>mount挂载</h3><p>weed mount 功能需要配合 Filer 才能使用，这样可以在服务器上用命令行操作文件。支持的操作如下：</p><ul><li>file read / write</li><li>create new file</li><li>mkdir</li><li>list</li><li>remove</li><li>rename</li><li>chmod</li><li>chown</li><li>soft link</li><li>display free disk space</li></ul><p>详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Mount" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Mount</a></p><h3 id="Amazon-S3-API"><a href="#Amazon-S3-API" class="headerlink" title="Amazon S3 API"></a>Amazon S3 API</h3><p>为了与<code>Amazon S3 API</code>兼容，提供了单独的<code>weed s3</code>命令。与在云上操作文件相比，这在读取或写入文件时提供了更快的访问权限。</p><p><code>weed s3</code>将启动无状态网关服务器，以将<code>Amazon S3 API</code>桥接到<code>SeaweedFS Filer</code>。为了方便起见，<code>weed server -s3</code>将启动主服务器，卷服务器，文件管理器和S3网关。</p><p>每个存储桶都存储在一个集合中，并且默认情况下映射到文件夹<code>/ buckets / &lt;bucket_name&gt;</code>。</p><p>通过删除整个集合，可以有效地删除存储桶。</p><p>当前，支持以下API。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Object operations</span><br><span class="line">* PutObject</span><br><span class="line">* GetObject</span><br><span class="line">* HeadObject</span><br><span class="line">* CopyObject</span><br><span class="line">* DeleteObject</span><br><span class="line">* ListObjectsV2</span><br><span class="line">* ListObjectsV1</span><br><span class="line"></span><br><span class="line">// Bucket operations</span><br><span class="line">* PutBucket</span><br><span class="line">* DeleteBucket</span><br><span class="line">* HeadBucket</span><br><span class="line">* ListBuckets</span><br><span class="line"></span><br><span class="line">// Multipart upload operations</span><br><span class="line">* NewMultipartUpload</span><br><span class="line">* CompleteMultipartUpload</span><br><span class="line">* AbortMultipartUpload</span><br><span class="line">* ListMultipartUploads</span><br><span class="line">* CopyObjectPart</span><br></pre></td></tr></table></figure><h1 id="0x06-异步备份"><a href="#0x06-异步备份" class="headerlink" title="0x06 异步备份"></a>0x06 异步备份</h1><h2 id="异步复制到另一个Filer"><a href="#异步复制到另一个Filer" class="headerlink" title="异步复制到另一个Filer"></a>异步复制到另一个Filer</h2><p>应该有两个Seaweed文件系统正在运行，可能跨数据中心运行。每个服务器都应具有其文件服务器，主服务器和卷服务器。</p><p><img src="https://github.com/chrislusf/seaweedfs/wiki/FilerAsyncReplication.png" alt="架构图"></p><p>详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Async-Replication-to-another-Filer" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Async-Replication-to-another-Filer</a></p><h2 id="备份到云"><a href="#备份到云" class="headerlink" title="备份到云"></a>备份到云</h2><p>诸如Amazon S3，Google Cloud Storage，Azure，Backblaze B2等云存储选项非常适合备份。</p><p>Filer中的每个文件更改都会触发通知发送到消息队列。<code>weed replicate</code>过程将从消息队列中读取，读取实际文件内容，然后将更新发送到云接收器。</p><p><img src="https://github.com/chrislusf/seaweedfs/wiki/FilerAsyncBackupToCloud.png" alt="结构图"></p><p>详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Backup-to-Cloud" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Backup-to-Cloud</a></p><h1 id="0x07-进阶"><a href="#0x07-进阶" class="headerlink" title="0x07 进阶"></a>0x07 进阶</h1><h2 id="复写配置"><a href="#复写配置" class="headerlink" title="复写配置"></a>复写配置</h2><p>SeaweedFS可以支持复制。复制不是在文件级别而是在卷级别实现的。</p><h3 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h3><ol><li><p>start weed master, and optionally specify the default replication type</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed master -defaultReplication=001</span><br></pre></td></tr></table></figure></li><li><p>start volume servers as this:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./weed volume -port=8081 -dir=/tmp/1 -max=100 -mserver="master_address:9333" -dataCenter=dc1 -rack=rack1</span><br><span class="line">./weed volume -port=8082 -dir=/tmp/2 -max=100 -mserver="master_address:9333" -dataCenter=dc1 -rack=rack1</span><br></pre></td></tr></table></figure></li></ol><p>On another rack,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./weed volume -port=8081 -dir=/tmp/1 -max=100 -mserver="master_address:9333" -dataCenter=dc1 -rack=rack2</span><br><span class="line">./weed volume -port=8082 -dir=/tmp/2 -max=100 -mserver="master_address:9333" -dataCenter=dc1 -rack=rack2</span><br></pre></td></tr></table></figure><p>No change to Submitting, Reading, and Deleting files.</p><h3 id="复写类型的含义"><a href="#复写类型的含义" class="headerlink" title="复写类型的含义"></a>复写类型的含义</h3><p><em>Note: This subject to change.</em></p><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>000</td><td>no replication, just one copy</td></tr><tr><td>001</td><td>replicate once on the same rack</td></tr><tr><td>010</td><td>replicate once on a different rack in the same data center</td></tr><tr><td>100</td><td>replicate once on a different data center</td></tr><tr><td>200</td><td>replicate twice on two other different data center</td></tr><tr><td>110</td><td>replicate once on a different rack, and once on a different data center</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>So if the replication type is xyz</p><table><thead><tr><th>Column</th><th>Meaning</th></tr></thead><tbody><tr><td><strong>x</strong></td><td>number of replica in other data centers</td></tr><tr><td><strong>y</strong></td><td>number of replica in other racks in the same data center</td></tr><tr><td><strong>z</strong></td><td>number of replica in other servers in the same rack</td></tr></tbody></table><p>x,y,z each can be 0, 1, or 2. So there are 9 possible replication types, and can be easily extended. Each replication type will physically create x+y+z+1 copies of volume data files.</p><h2 id="大文件处理"><a href="#大文件处理" class="headerlink" title="大文件处理"></a>大文件处理</h2><p>为了支持大文件，SeaweedFS支持以下两种文件：</p><ul><li>块文件。每个块文件实际上只是SeaweedFS的普通文件。</li><li>块清单。一个带有所有块列表的简单json文件。</li></ul><p>更多详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Large-File-Handling" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Large-File-Handling</a></p><h2 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h2><p><code>weed scaffold -config=security</code> 生成<code>security.toml</code></p><p><code>security.toml</code>文件示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Put this file to one of the location, with descending priority</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    ./security.toml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="variable">$HOME</span>/.seaweedfs/security.toml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    /etc/seaweedfs/security.toml</span></span><br><span class="line"></span><br><span class="line">[jwt.signing]</span><br><span class="line">key = "blahblahblahblah"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> all grpc tls authentications are mutual </span></span><br><span class="line">[grpc]</span><br><span class="line">ca = "/Users/ghostsf/.seaweedfs/out/SeaweedFS_CA.crt"</span><br><span class="line"></span><br><span class="line">[grpc.volume]</span><br><span class="line">cert = "/Users/ghostsf/.seaweedfs/out/volume01.crt"</span><br><span class="line">key  = "/Users/ghostsf/.seaweedfs/out/volume01.key"</span><br><span class="line"></span><br><span class="line">[grpc.master]</span><br><span class="line">cert = "/Users/ghostsf/.seaweedfs/out/master01.crt"</span><br><span class="line">key  = "/Users/ghostsf/.seaweedfs/out/master01.key"</span><br><span class="line"></span><br><span class="line">[grpc.filer]</span><br><span class="line">cert = "/Users/ghostsf/.seaweedfs/out/filer01.crt"</span><br><span class="line">key  = "/Users/ghostsf/.seaweedfs/out/filer01.key"</span><br><span class="line"></span><br><span class="line">[grpc.client]</span><br><span class="line">cert = "/Users/ghostsf/.seaweedfs/out/client01.crt"</span><br><span class="line">key  = "/Users/ghostsf/.seaweedfs/out/client01.key"</span><br></pre></td></tr></table></figure><h1 id="0x08-各语言的客户端"><a href="#0x08-各语言的客户端" class="headerlink" title="0x08 各语言的客户端"></a>0x08 各语言的客户端</h1><p>目前官方提供了足够的Api，各种语言的客户端也都有了。</p><p>详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Client-Libraries" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Client-Libraries</a></p><h1 id="0x09-不足与问题"><a href="#0x09-不足与问题" class="headerlink" title="0x09 不足与问题"></a>0x09 不足与问题</h1><ol><li>seaweedfs 采用的是同步式复写有以下几个问题：</li></ol><ul><li><p>当在某个volume-server 下线又上线恢复的情况下，没有自动的同步机制</p></li><li><p>同步复写需要等待每个节点都复写成功，效率相对较低</p></li><li><p>虽然节点的上下线会快速通过心跳通知master节点，但是仍然存在一定的延迟，期间Volume-Server在复写的时候可能会出现因为复写已经下线的volume-server导致上传失败的情况</p></li></ul><ol start="2"><li>seaweedfs目前在权限管理方面还相对比较弱，目前仅有一个白名单控制机制，来控制外部的读写权限/恶意删除。</li></ol><h1 id="0x10-遇到问题怎么办"><a href="#0x10-遇到问题怎么办" class="headerlink" title="0x10 遇到问题怎么办"></a>0x10 遇到问题怎么办</h1><ul><li><p><a href="https://github.com/chrislusf/seaweedfs/wiki" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki</a></p></li><li><p><a href="https://github.com/chrislusf/seaweedfs/issues" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/issues</a></p></li><li><p><a href="https://github.com/chrislusf/seaweedfs/community" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/community</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chrislusf/seaweedfs/master/note/seaweedfs.png&quot; alt=&quot;SeaweedFS Logo&quot;&gt;&lt;/p&gt;&lt;p&gt;Github: &lt;a href=&quot;https://github.com/chrislusf/seaweedfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/chrislusf/seaweedfs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/chrislusf/seaweedfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://travis-ci.org/chrislusf/seaweedfs.svg?branch=master&quot; alt=&quot;Build Status&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://godoc.org/github.com/chrislusf/seaweedfs/weed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://godoc.org/github.com/chrislusf/seaweedfs/weed?status.svg&quot; alt=&quot;GoDoc&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/chrislusf/seaweedfs/wiki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/docs-wiki-blue.svg&quot; alt=&quot;Wiki&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://hub.docker.com/r/chrislusf/seaweedfs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/docker/pulls/chrislusf/seaweedfs.svg?maxAge=604800&quot; alt=&quot;Docker Pulls&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;SeaweedFS is a simple and highly scalable distributed file system, to store and serve billions of files fast! SeaweedFS implements an object store with O(1) disk seek, transparent cloud integration, and an optional Filer with POSIX interface, supporting S3 API, Rack-Aware Erasure Coding for warm storage, FUSE mount, Hadoop compatible, WebDAV.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;SeaweedFS是一个简单且高度可扩展的分布式文件系统，可以快速存储和提供数十亿个文件！SeaweedFS通过 O(1) 磁盘搜索，透明云集成以及带有POSIX接口的可选Filer，实现了对象存储，支持S3 API，用于热存储的机架感知擦除编码，FUSE安装，Hadoop兼容，WebDAV。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="SeaweedFS" scheme="https://ghostsf.com/tags/SeaweedFS/"/>
    
      <category term="分布式" scheme="https://ghostsf.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="文件系统" scheme="https://ghostsf.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《江湖风云录之民谣》何教授2019 带歌词</title>
    <link href="https://ghostsf.com/qnmlgb/"/>
    <id>https://ghostsf.com/qnmlgb/</id>
    <published>2020-02-22T21:20:08.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<p>《江湖风云录之民谣》何教授2019.5.25 沈阳</p><blockquote><p>给大家配上了歌词，敬请欣赏 = =</p></blockquote><div id="player-qnmlgb"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-qnmlgb"),video:{url:"https://cdn.ghostsf.com/%E6%B1%9F%E6%B9%96%E9%A3%8E%E4%BA%91%E5%BD%95%E4%B9%8B%E6%B0%91%E8%B0%A3.mp4"}})</script><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《江湖风云录之民谣》何教授2019.5.25 沈阳&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;给大家配上了歌词，敬请欣赏 = =&lt;/p&gt;&lt;/blockquote&gt;&lt;div id=&quot;player-qnmlgb&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;new DPlayer({container:document.getElementById(&quot;player-qnmlgb&quot;),video:{url:&quot;https://cdn.ghostsf.com/%E6%B1%9F%E6%B9%96%E9%A3%8E%E4%BA%91%E5%BD%95%E4%B9%8B%E6%B0%91%E8%B0%A3.mp4&quot;}})&lt;/script&gt;
    
    </summary>
    
    
      <category term="闲言语" scheme="https://ghostsf.com/categories/%E9%97%B2%E8%A8%80%E8%AF%AD/"/>
    
      <category term="创作集" scheme="https://ghostsf.com/categories/%E9%97%B2%E8%A8%80%E8%AF%AD/%E5%88%9B%E4%BD%9C%E9%9B%86/"/>
    
    
      <category term="民谣" scheme="https://ghostsf.com/tags/%E6%B0%91%E8%B0%A3/"/>
    
  </entry>
  
  <entry>
    <title>逆行的伞</title>
    <link href="https://ghostsf.com/%E9%80%86%E8%A1%8C%E7%9A%84%E4%BC%9E/"/>
    <id>https://ghostsf.com/%E9%80%86%E8%A1%8C%E7%9A%84%E4%BC%9E/</id>
    <published>2020-02-14T10:53:01.000Z</published>
    <updated>2020-03-08T09:47:34.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆行的伞"><a href="#逆行的伞" class="headerlink" title="逆行的伞"></a>逆行的伞</h2><blockquote><p>写于2011年8月23日 14时</p></blockquote><p><img src="../images/post/%E9%80%86%E8%A1%8C%E7%9A%84%E4%BC%9E.jpeg" alt="逆行的伞"></p><p>独自<br>撑着一纸的孤单<br>任雨<br>在头顶轻叹<br>我在人群拥挤中逆行<br>渐渐丢了<br>手中握紧的伞<br>依稀<br>我看见水洼中倒映的脸<br>彷徨不安</p><hr><p>独自<br>撑着一纸的茫然<br>任雨<br>掉落无言的悲欢<br>我与人群擦肩而行<br>似乎想起<br>去年身旁的伞<br>如果<br>我期待那一瞬的相视无言<br>不问不管</p><hr><p>独自<br>撑着一纸的遗憾<br>任雨<br>溅湿双脚的蹒跚<br>人群在我的思绪中逆行<br>使我忘了<br>捡起丢落一旁的伞<br>于是<br>我祈祷前方背影的黯淡<br>顾首回盼</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;逆行的伞&quot;&gt;&lt;a href=&quot;#逆行的伞&quot; class=&quot;headerlink&quot; title=&quot;逆行的伞&quot;&gt;&lt;/a&gt;逆行的伞&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;写于2011年8月23日 14时&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;../i
      
    
    </summary>
    
    
      <category term="文艺斋" scheme="https://ghostsf.com/categories/%E6%96%87%E8%89%BA%E6%96%8B/"/>
    
    
      <category term="旧文字" scheme="https://ghostsf.com/tags/%E6%97%A7%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>git-bundle</title>
    <link href="https://ghostsf.com/git-bundle/"/>
    <id>https://ghostsf.com/git-bundle/</id>
    <published>2020-01-16T09:53:06.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-工具-打包-bundle"><a href="#Git-工具-打包-bundle" class="headerlink" title="Git 工具 - 打包 - bundle"></a>Git 工具 - 打包 - bundle</h2><p>虽然我们已经了解了网络传输 Git 数据的常用方法（如 HTTP，SSH 等），但还有另外一种不太常见却又十分有用的方式。</p><p>Git 可以将它的数据“打包”到一个文件中。 这在许多场景中都很有用。 有可能你的网络中断了，但你又希望将你的提交传给你的合作者们。 可能你不在办公网中并且出于安全考虑没有给你接入内网的权限。 可能你的无线、有线网卡坏掉了。 可能你现在没有共享服务器的权限，你又希望通过邮件将更新发送给别人，却不希望通过 format-patch 的方式传输 40 个提交。</p><p>这些情况下 git bundle 就会很有用。 bundle 命令会将 git push 命令所传输的所有内容打包成一个二进制文件，你可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。</p><p>来看看一个简单的例子。 假设你有一个包含两个提交的仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git log  </span><br><span class="line">commit 9a466c572fe88b195efd356c3f2bbeccdb504102  </span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;  </span><br><span class="line">Date:   Wed Mar 10 07:34:10 2010 -0800  </span><br><span class="line">    second commit  </span><br><span class="line"></span><br><span class="line">commit b1ec3248f39900d2a406049d762aa68e9641be25  </span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;  </span><br><span class="line">Date:   Wed Mar 10 07:34:01 2010 -0800  </span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>如果你想把这个仓库发送给其他人但你没有其他仓库的权限，或者就是懒得新建一个仓库，你就可以用 git bundle create 命令来打包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle create repo.bundle HEAD master  </span><br><span class="line">Counting objects: 6, done.  </span><br><span class="line">Delta compression using up to 2 threads.    </span><br><span class="line">Compressing objects: 100% (2&#x2F;2), done.  </span><br><span class="line">Writing objects: 100% (6&#x2F;6), 441 bytes, done.  </span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br></pre></td></tr></table></figure><p>然后你就会有一个名为 repo.bundle 的文件，该文件包含了所有重建该仓库 master 分支所需的数据。 在使用 bundle 命令时，你需要列出所有你希望打包的引用或者提交的区间。 如果你希望这个仓库可以在别处被克隆，你应该像例子中那样增加一个 HEAD 引用。</p><p>你可以将这个 repo.bundle 文件通过邮件或者U盘传给别人。</p><p>另一方面，假设别人传给你一个 repo.bundle 文件并希望你在这个项目上工作。 你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone repo.bundle repo  </span><br><span class="line">Initialized empty Git repository in &#x2F;private&#x2F;tmp&#x2F;bundle&#x2F;repo&#x2F;.git&#x2F;  </span><br><span class="line">$ cd repo  </span><br><span class="line">$ git log --oneline  </span><br><span class="line">9a466c5 second commit </span><br><span class="line">b1ec324 first commit</span><br></pre></td></tr></table></figure><p>如果你在打包时没有包含 HEAD 引用，你还需要在命令后指定一个 -b master 或者其他被引入的分支，否则 Git 不知道应该检出哪一个分支。</p><p>现在假设你提交了 3 个修订，并且要用邮件或者U盘将新的提交放在一个包里传回去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline  </span><br><span class="line">71b84da last commit - second repo  </span><br><span class="line">c99cf5b fourth commit - second repo  </span><br><span class="line">7011d3d third commit - second repo  </span><br><span class="line">9a466c5 second commit  </span><br><span class="line">b1ec324 first commit</span><br></pre></td></tr></table></figure><p>首先我们需要确认我们希望被打包的提交区间。 和网络协议不太一样，网络协议会自动计算出所需传输的最小数据集，而我们需要手动计算。 当然你可以像上面那样将整个仓库打包，但最好仅仅打包变更的部分 —— 就是我们刚刚在本地做的 3 个提交。</p><p>为了实现这个目标，你需要计算出差别。 就像我们在 提交区间 介绍的，你有很多种方式去指明一个提交区间。 我们可以使用 origin/master..master 或者 master ^origin/master 之类的方法来获取那 3 个在我们的 master 分支而不在原始仓库中的提交。 你可以用 log 命令来测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline master ^origin&#x2F;master </span><br><span class="line">71b84da last commit - second repo  </span><br><span class="line">c99cf5b fourth commit - second repo  </span><br><span class="line">7011d3d third commit - second repo</span><br></pre></td></tr></table></figure><p>这样就获取到我们希望被打包的提交列表，让我们将这些提交打包。 我们可以用 git bundle create 命令，加上我们想用的文件名，以及要打包的提交区间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle create commits.bundle master ^9a466c5  </span><br><span class="line">Counting objects: 11, done.  </span><br><span class="line">Delta compression using up to 2 threads.  </span><br><span class="line">Compressing objects: 100% (3&#x2F;3), done.  </span><br><span class="line">Writing objects: 100% (9&#x2F;9), 775 bytes, done.  </span><br><span class="line">Total 9 (delta 0), reused 0 (delta 0)</span><br></pre></td></tr></table></figure><p>现在在我们的目录下会有一个 commits.bundle 文件。 如果我们把这个文件发送给我们的合作者，她可以将这个文件导入到原始的仓库中，即使在这期间已经有其他的工作提交到这个仓库中。</p><p>当她拿到这个包时，她可以在导入到仓库之前查看这个包里包含了什么内容。 bundle verify 命令可以检查这个文件是否是一个合法的 Git 包，是否拥有共同的祖先来导入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle verify ..&#x2F;commits.bundle  </span><br><span class="line">The bundle contains 1 ref  </span><br><span class="line">71b84daaf49abed142a373b6e5c59a22dc6560dc refs&#x2F;heads&#x2F;master  </span><br><span class="line">The bundle requires these 1 ref  </span><br><span class="line">9a466c572fe88b195efd356c3f2bbeccdb504102 second commit  </span><br><span class="line">..&#x2F;commits.bundle is okay</span><br></pre></td></tr></table></figure><p>如果打包工具仅仅把最后两个提交打包，而不是三个，原始的仓库是无法导入这个包的，因为这个包缺失了必要的提交记录。这时候 verify 的输出类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle verify ..&#x2F;commits-bad.bundle  </span><br><span class="line">error: Repository lacks these prerequisite commits:   </span><br><span class="line">error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo</span><br></pre></td></tr></table></figure><p>而我们的第一个包是合法的，所以我们可以从这个包里提取出提交。 如果你想查看这边包里可以导入哪些分支，同样有一个命令可以列出这些顶端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle list-heads ..&#x2F;commits.bundle  </span><br><span class="line">71b84daaf49abed142a373b6e5c59a22dc6560dc refs&#x2F;heads&#x2F;master</span><br></pre></td></tr></table></figure><p>verify 子命令同样可以告诉你有哪些顶端。 该功能的目的是查看哪些是可以被拉入的，所以你可以使用 fetch 或者 pull 命令从包中导入提交。 这里我们要从包中取出 master 分支到我们仓库中的 other-master 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch ..&#x2F;commits.bundle master:other-master  </span><br><span class="line">From ..&#x2F;commits.bundle  </span><br><span class="line"> * [new branch]      master     -&gt; other-master</span><br></pre></td></tr></table></figure><p>可以看到我们已经将提交导入到 other-master 分支，以及在这期间我们自己在 master 分支上的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph --all  </span><br><span class="line">* 8255d41 (HEAD, master) third commit - first repo  </span><br><span class="line">| * 71b84da (other-master) last commit - second repo  </span><br><span class="line">| * c99cf5b fourth commit - second repo  </span><br><span class="line">| * 7011d3d third commit - second repo  </span><br><span class="line">|&#x2F;  </span><br><span class="line">* 9a466c5 second commit  </span><br><span class="line">* b1ec324 first commit</span><br></pre></td></tr></table></figure><p>因此，当你在没有合适的网络或者可共享仓库的情况下，git bundle 很适合用于共享或者网络类型的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-工具-打包-bundle&quot;&gt;&lt;a href=&quot;#Git-工具-打包-bundle&quot; class=&quot;headerlink&quot; title=&quot;Git 工具 - 打包 - bundle&quot;&gt;&lt;/a&gt;Git 工具 - 打包 - bundle&lt;/h2&gt;&lt;p&gt;虽然我们已经
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="git" scheme="https://ghostsf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Vlog0x01 - IKBC F87 时光机 清洗记</title>
    <link href="https://ghostsf.com/vlog1/"/>
    <id>https://ghostsf.com/vlog1/</id>
    <published>2020-01-03T09:39:38.000Z</published>
    <updated>2020-03-08T09:47:34.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vlog0x01-IKBC-F87-时光机-清洗记"><a href="#Vlog0x01-IKBC-F87-时光机-清洗记" class="headerlink" title="Vlog0x01 - IKBC F87 时光机 清洗记"></a>Vlog0x01 - IKBC F87 时光机 清洗记</h2><p><a href="https://www.bilibili.com/video/av81643587/" target="_blank" rel="noopener">https://www.bilibili.com/video/av81643587/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vlog0x01-IKBC-F87-时光机-清洗记&quot;&gt;&lt;a href=&quot;#Vlog0x01-IKBC-F87-时光机-清洗记&quot; class=&quot;headerlink&quot; title=&quot;Vlog0x01 - IKBC F87 时光机 清洗记&quot;&gt;&lt;/a&gt;Vlog0x01 
      
    
    </summary>
    
    
      <category term="创作集" scheme="https://ghostsf.com/categories/%E5%88%9B%E4%BD%9C%E9%9B%86/"/>
    
    
      <category term="vlog" scheme="https://ghostsf.com/tags/vlog/"/>
    
  </entry>
  
  <entry>
    <title>未知生物圣诞游行</title>
    <link href="https://ghostsf.com/christmas/"/>
    <id>https://ghostsf.com/christmas/</id>
    <published>2019-12-26T13:49:41.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="未知生物圣诞游行-直通"><a href="#未知生物圣诞游行-直通" class="headerlink" title="未知生物圣诞游行 直通"></a><a href="https://www.bilibili.com/video/av80718385/" target="_blank" rel="noopener">未知生物圣诞游行 直通</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;未知生物圣诞游行-直通&quot;&gt;&lt;a href=&quot;#未知生物圣诞游行-直通&quot; class=&quot;headerlink&quot; title=&quot;未知生物圣诞游行 直通&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/av80718385/&quot; 
      
    
    </summary>
    
    
      <category term="创作集" scheme="https://ghostsf.com/categories/%E5%88%9B%E4%BD%9C%E9%9B%86/"/>
    
    
      <category term="圣诞节" scheme="https://ghostsf.com/tags/%E5%9C%A3%E8%AF%9E%E8%8A%82/"/>
    
      <category term="vlog" scheme="https://ghostsf.com/tags/vlog/"/>
    
  </entry>
  
  <entry>
    <title>修改git历史提交信息</title>
    <link href="https://ghostsf.com/git-commit-change/"/>
    <id>https://ghostsf.com/git-commit-change/</id>
    <published>2019-12-26T10:33:53.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<p>修复 git 历史提交信息<br>To change the name and/or email address recorded in existing commits, you must rewrite the entire history of your Git repository.</p><p>为了修改 commit 的作者邮箱地址，你必须重写整个 git 仓库历史</p><p>Warning: This action is destructive to your repository’s history. If you’re collaborating on a repository with others, it’s considered bad practice to rewrite published history. You should only do this in an emergency.</p><p>警告： 这个操作会破坏你的仓库历史， 如果你和别人在协同开发这个仓库，重写已发布的历史记录是一个不好的操作。建议只在紧急情况操作</p><p>操作步骤：</p><a id="more"></a><p>打开 bash</p><p>Create a fresh, bare clone of your repository: （新建一个全新的仓库信息：)</p><pre><code>git clone --bare https://github.com/user/repo.gitcd repo.git</code></pre><p>Copy and paste the script, replacing the following variables based on the information you gathered: (在终端复制并粘贴以下脚本，并将以下的变量修改为你需要的)</p><p><strong>OLD_EMAIL</strong></p><p><strong>CORRECT_NAME</strong></p><p><strong>CORRECT_EMAIL</strong></p><p>脚本信息：</p><p><a href="https://gist.github.com/ghostsf/de39ebde3a50b0fcaf4f3de172940969" target="_blank" rel="noopener">git-commit-change.sh</a></p><p>Press Enter to run the script.（按下 enter 键来运行这个脚本</p><p>Review the new Git history for errors.(校对新的 git 仓库历史）</p><p>Push the corrected history to GitHub:（将修改后的仓库历史推到远程）</p><p>git push –force –tags origin ‘refs/heads/*’<br>Clean up the temporary clone: (删除这个仓库)</p><p>cd ..<br>rm -rf repo.git</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修复 git 历史提交信息&lt;br&gt;To change the name and/or email address recorded in existing commits, you must rewrite the entire history of your Git repository.&lt;/p&gt;&lt;p&gt;为了修改 commit 的作者邮箱地址，你必须重写整个 git 仓库历史&lt;/p&gt;&lt;p&gt;Warning: This action is destructive to your repository’s history. If you’re collaborating on a repository with others, it’s considered bad practice to rewrite published history. You should only do this in an emergency.&lt;/p&gt;&lt;p&gt;警告： 这个操作会破坏你的仓库历史， 如果你和别人在协同开发这个仓库，重写已发布的历史记录是一个不好的操作。建议只在紧急情况操作&lt;/p&gt;&lt;p&gt;操作步骤：&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="git" scheme="https://ghostsf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>tar命令参数</title>
    <link href="https://ghostsf.com/tar/"/>
    <id>https://ghostsf.com/tar/</id>
    <published>2019-12-24T17:07:19.000Z</published>
    <updated>2020-03-08T09:47:34.603Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tar命令参数说明"><a href="#tar命令参数说明" class="headerlink" title="tar命令参数说明"></a>tar命令参数说明</h3><p>-c : 建立一个打包文件；</p><p>-x ：解开一个打包文件；</p><p>-t ：查看 tar包里面的文件；</p><p>（特别注意，在选择参数时，c/x/t仅能存在一个，不可同时存在，因为不可能同时压缩与解压缩。）</p><p>-z ：打包后用gzip压缩，生成.tar.gz文件；</p><p>-j ：打包后用zip2压缩，生成.tar.bz2文件；</p><p>-v ：压缩的过程中显示文件；</p><p>-f ：使用文件名，请留意，在f之后要立即接文件名，不要再加其它参数；</p><p>-p ：保持原文件的属性；</p><p>-P ：使用绝对路径来压缩；</p><p>-N ：设定日期(yyyy/mm/dd)，比后面接的日期还要新的文件才会被打包进新建的文件中；</p><p>–exclude FILE：在打包的过程中，不要将FILE打包。</p><blockquote><ul><li><ul><li>可能我用得少，老记不住 这里初步整理下</li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;tar命令参数说明&quot;&gt;&lt;a href=&quot;#tar命令参数说明&quot; class=&quot;headerlink&quot; title=&quot;tar命令参数说明&quot;&gt;&lt;/a&gt;tar命令参数说明&lt;/h3&gt;&lt;p&gt;-c : 建立一个打包文件；&lt;/p&gt;&lt;p&gt;-x ：解开一个打包文件；&lt;/p&gt;&lt;p&gt;-
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="linux" scheme="https://ghostsf.com/tags/linux/"/>
    
      <category term="tar" scheme="https://ghostsf.com/tags/tar/"/>
    
  </entry>
  
  <entry>
    <title>自建maven私有仓库实践</title>
    <link href="https://ghostsf.com/nexus/"/>
    <id>https://ghostsf.com/nexus/</id>
    <published>2019-12-24T15:20:35.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一次自建maven私有仓库的过程 = = ， 其实是为了凑个更新</p></blockquote><h2 id="0x01-仓库管理软件"><a href="#0x01-仓库管理软件" class="headerlink" title="0x01 仓库管理软件"></a>0x01 仓库管理软件</h2><p>目前比较流行的有Apache基金会的 Archiva，JFrog 的 Artifactory ，Sonatypec 的 Nexus</p><h2 id="0x02-环境"><a href="#0x02-环境" class="headerlink" title="0x02 环境"></a>0x02 环境</h2><p>要求 Java 8 Runtime Environment或者以上</p><h2 id="0x03-下载运行Nexus"><a href="#0x03-下载运行Nexus" class="headerlink" title="0x03 下载运行Nexus"></a>0x03 下载运行Nexus</h2><p>去 <a href="https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3" target="_blank" rel="noopener">官网</a> 根据你的操作系统选择下载</p><p>进入bin目录，运行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Unix &amp; OS X</span><br><span class="line">.&#x2F;nexus run</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Windows  </span><br><span class="line">nexus.exe &#x2F;run</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nexus run 前台运行，可以实时查看运行log</span><br><span class="line"></span><br><span class="line">nexus start 后台运行</span><br><span class="line"></span><br><span class="line">nexus stop 关闭</span><br></pre></td></tr></table></figure><p>默认端口: 8081</p><p>默认的管理员账号密码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username：admin</span><br><span class="line">password：admin123</span><br></pre></td></tr></table></figure><p>nexus3 安全性提高了些，admin的密码在<code>~/sonatype-work/nexus3/admin.password</code>文件里</p><h2 id="0x04-配置"><a href="#0x04-配置" class="headerlink" title="0x04 配置"></a>0x04 配置</h2><p>配置文件地址</p><p><code>./etc/nexus-default.properties</code> 可配置端口等参数</p><p><code>./bin/nexus.vmoptions</code> 可配置数据存储的目录以及内存参数等</p><h2 id="0x05-其他配置"><a href="#0x05-其他配置" class="headerlink" title="0x05 其他配置"></a>0x05 其他配置</h2><p><strong>服务自启</strong></p><p>在/etc/systemd/system/下创建nexus.service文件</p><p><code>vi /etc/systemd/system/nexus.service</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"></span><br><span class="line">Description&#x3D;nexus service</span><br><span class="line"></span><br><span class="line">After&#x3D;network.target</span><br><span class="line">  </span><br><span class="line">[Service]</span><br><span class="line"></span><br><span class="line">Type&#x3D;forking</span><br><span class="line"></span><br><span class="line">LimitNOFILE&#x3D;65536</span><br><span class="line"></span><br><span class="line">ExecStart&#x3D;~&#x2F;bin&#x2F;nexus start</span><br><span class="line"></span><br><span class="line">ExecStop&#x3D;~&#x2F;bin&#x2F;nexus stop</span><br><span class="line"></span><br><span class="line">User&#x3D;nexus</span><br><span class="line"></span><br><span class="line">Restart&#x3D;on-abort</span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line"></span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p><strong>systemctl命令</strong></p><p>更新systemctl</p><p><code>sudo systemctl daemon-reload</code></p><p>设置开机启动</p><p><code>sudo systemctl enable nexus.service</code></p><p>启动nexus服务</p><p><code>sudo systemctl start nexus.service</code></p><p>查看nexus服务状态</p><p><code>sudo systemctl status nexus.service</code></p><p>查看日志</p><p><code>tail -f ~/sonatype-work/nexus3/log/nexus.log</code></p><h2 id="0x06-使用配置"><a href="#0x06-使用配置" class="headerlink" title="0x06 使用配置"></a>0x06 使用配置</h2><p><strong>maven</strong></p><p><strong>maven发布包</strong></p><p>pom.xml 参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;id&gt;nexus-releases&lt;&#x2F;id&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;name&gt;private-nexus-library-releases&lt;&#x2F;name&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;url&gt;http:&#x2F;&#x2F;&#123;host&#125;&#x2F;repository&#x2F;maven-releases&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;repository&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;snapshotRepository&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;id&gt;nexus-snapshots&lt;&#x2F;id&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;name&gt;private-nexus-library-snapshots&lt;&#x2F;name&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;url&gt;http:&#x2F;&#x2F;&#123;host&#125;&#x2F;repository&#x2F;maven-snapshots&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;snapshotRepository&gt;</span><br><span class="line">&lt;&#x2F;distributionManagement&gt;</span><br></pre></td></tr></table></figure><p>maven settings.xml 参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;servers&gt;</span><br><span class="line"></span><br><span class="line">&lt;server&gt;</span><br><span class="line"></span><br><span class="line">  &lt;id&gt;nexus-releases&lt;&#x2F;id&gt;</span><br><span class="line"></span><br><span class="line">  &lt;username&gt;username&lt;&#x2F;username&gt;</span><br><span class="line"></span><br><span class="line">  &lt;password&gt;password&lt;&#x2F;password&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;server&gt;</span><br><span class="line"></span><br><span class="line">&lt;server&gt;</span><br><span class="line"></span><br><span class="line">  &lt;id&gt;nexus-snapshots&lt;&#x2F;id&gt;</span><br><span class="line"></span><br><span class="line">  &lt;username&gt;username&lt;&#x2F;username&gt;</span><br><span class="line"></span><br><span class="line">  &lt;password&gt;password&lt;&#x2F;password&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;server&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;servers&gt;</span><br></pre></td></tr></table></figure><p>*<em>maven使用 *</em></p><p>mirrors add</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-private<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus private<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;host&#125;/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ps：若设置了不允许匿名用户访问<br>则使用远程仓库的时候需要使用鉴权URL</p><p>eg:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-private<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus private<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;username&#125;:&#123;password&#125;@&#123;host&#125;/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>// todo 还有很多要整理 有空出个相关专题文章吧</p><h2 id="0x07-注意事项"><a href="#0x07-注意事项" class="headerlink" title="0x07 注意事项"></a>0x07 注意事项</h2><p><strong>修改运行用户</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARNING: ************************************************************</span><br><span class="line"></span><br><span class="line">WARNING: Detected execution as "root" user.  This is NOT recommended!</span><br><span class="line"></span><br><span class="line">WARNING: ************************************************************</span><br></pre></td></tr></table></figure><p>创建一个单独的用户进行运行，安全一些</p><p><code>adduser nexus</code></p><p><code>passwd nexus</code></p><p>然后修改nexus为运行用户</p><p><code>vi ./bin/nexus.rc</code></p><p>取消注释，并修改为如下内容</p><p><code>run_as_user=&quot;nexus&quot;</code></p><p>修改nexus3文件的所有者</p><p><code>chown -R nexus:nexus ~/nexus3/</code></p><p><strong>备份迁移</strong></p><p>默认配置 nexus的数据都在此目录下</p><p><code>sonatype-work</code></p><p>该目录可在<code>./bin/nexus.vmoptions</code>自定义配置</p><p>需要备份迁移，只要打包这个目录即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;记录一次自建maven私有仓库的过程 = = ， 其实是为了凑个更新&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;0x01-仓库管理软件&quot;&gt;&lt;a href=&quot;#0x01-仓库管理软件&quot; class=&quot;headerlink&quot; title=&quot;0x01
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="maven" scheme="https://ghostsf.com/tags/maven/"/>
    
      <category term="nexus" scheme="https://ghostsf.com/tags/nexus/"/>
    
      <category term="私有仓库" scheme="https://ghostsf.com/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>免费BT离线下载收集</title>
    <link href="https://ghostsf.com/bt/"/>
    <id>https://ghostsf.com/bt/</id>
    <published>2019-12-23T11:41:40.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="left">名称</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">OffCloud</td><td align="left">单文件无限制，总空间 100G</td></tr><tr><td align="left">Streamza</td><td align="left">单文件 1G 限制，队列 1，无法下载回本地，可在线</td></tr><tr><td align="left">BytesLoader</td><td align="left">单文件无限制，队列 2</td></tr><tr><td align="left">FURK</td><td align="left">单文件 2G 限制，队列 2，可在线</td></tr><tr><td align="left">DirectTorrents</td><td align="left">总文件 10G 限制 队列 3</td></tr><tr><td align="left">Zbigz</td><td align="left">单文件 1G 限制，队列 2，限速 150K，7 天保存</td></tr><tr><td align="left">FileStream</td><td align="left">单文件 1G 限制，队列 2，3 天保存</td></tr><tr><td align="left">FilesLoop</td><td align="left">单文件 1G 限制，队列 1</td></tr><tr><td align="left">BitPort</td><td align="left">单文件 1G 限制，队列 1</td></tr><tr><td align="left">Seedr</td><td align="left">单文件 2G 限制，队列 1</td></tr><tr><td align="left">ByteBX</td><td align="left">单文件 100M 限制，队列不限，总空间 2.5G</td></tr><tr><td align="left">TorrentSafe</td><td align="left">单文件无限制，月队列 3，总空间 10G</td></tr><tr><td align="left">2Giga</td><td align="left">单文件 2G 限制，队列 1</td></tr><tr><td align="left">SonicSeedbox</td><td align="left">单文件无限制，天队列 2，总空间 4G</td></tr><tr><td align="left">HiperDown</td><td align="left">单文件无限制，队列 2，总空间 5G</td></tr></tbody></table><blockquote><p>版权声明：转载自 <a href="https://imoe.xyz/post/120.html" target="_blank" rel="noopener">《免费BT离线下载服务汇总》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;名称&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;介绍&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;OffCloud&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;单文件
      
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="BT" scheme="https://ghostsf.com/tags/BT/"/>
    
      <category term="免费" scheme="https://ghostsf.com/tags/%E5%85%8D%E8%B4%B9/"/>
    
  </entry>
  
  <entry>
    <title>群辉玩物下载套件</title>
    <link href="https://ghostsf.com/dsm-xunlei/"/>
    <id>https://ghostsf.com/dsm-xunlei/</id>
    <published>2019-12-06T14:37:43.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<p>正愁黑群辉没有一个给力的下载器的时候。（Transmission 、 docker+aria2 都不是很理想）</p><blockquote><p>9月20日，NAS大厂群晖科技在上海举办了Synology 2020年度大会，会上宣布与迅雷合作，推出“玩物下载”套件。</p></blockquote><p>那么就美滋滋了。</p><blockquote><p>在群晖NAS里，安装玩物套件并且绑定迅雷帐号后，可以直接将下载的多媒体文件存储在NAS里。出门在外时，远程访问DSM操作下载，回到家即可享受大片。</p></blockquote><p>迫不及待地，安装，试用了。</p><p>emm，真香，基本都是满速。有的比pc上的迅雷都要快很多。</p><p>界面很简单，简单得没什么好操作的 = =</p><p><img src="/images/post/dsm-xunlei.png" alt="玩物下载"></p><p>瞄一眼这速度~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正愁黑群辉没有一个给力的下载器的时候。（Transmission 、 docker+aria2 都不是很理想）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;9月20日，NAS大厂群晖科技在上海举办了Synology 2020年度大会，会上宣布与迅雷合作，推出“玩物下载”套件。&lt;/p
      
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="群辉" scheme="https://ghostsf.com/tags/%E7%BE%A4%E8%BE%89/"/>
    
  </entry>
  
  <entry>
    <title>安利一款游戏《战双帕弥什》</title>
    <link href="https://ghostsf.com/pns-kurogame/"/>
    <id>https://ghostsf.com/pns-kurogame/</id>
    <published>2019-12-06T14:00:09.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<div id="player-pns"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-pns"),video:{url:"http://cdnstatic.kurogame.com/pns/2.0/images/video1.mp4"}})</script><p>《战双帕弥什》是广州库洛科技有限公司研发的一款末世科幻题材的3D动作手游。你将化身指挥官，带领人类最后的希望——仿生人形「构造体」，共同对抗被「帕弥什」病毒感染的机械大军。运用你的判断力，灵活地滑动指尖，触发不同的技能招式，在世界的终焉打出华丽一战吧！</p><a id="more"></a><h2 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h2><h3 id="资料001"><a href="#资料001" class="headerlink" title="资料001"></a>资料001</h3><div id="player-1"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-1"),video:{url:"http://video.zspns.kurogame.com/hd/2f317626420f4cf99f6d8ec4c2b17568.mp4",pic:"http://cdnimg02.kurogame.com/M00/14/82/ChpCl13nYT2ELg1_AAAAAKugTRY122.jpg"}})</script><h3 id="资料002"><a href="#资料002" class="headerlink" title="资料002"></a>资料002</h3><div id="player-2"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-2"),video:{url:"http://video.zspns.kurogame.com/hd/2f317626420f4cf99f6d8ec4c2b17568.mp4",pic:"http://cdnimg01.kurogame.com/M00/14/82/ChpCl13nao2EPxARAAAAABXzQNo687.jpg"}})</script><h2 id="壁纸欣赏"><a href="#壁纸欣赏" class="headerlink" title="壁纸欣赏"></a>壁纸欣赏</h2><h3 id="丽芙-纯白之花"><a href="#丽芙-纯白之花" class="headerlink" title="丽芙-纯白之花"></a>丽芙-纯白之花</h3><p><img src="/images/post/pns-5.jpg" alt="丽芙-纯白之花"></p><h3 id="比安卡-严霜凛雪"><a href="#比安卡-严霜凛雪" class="headerlink" title="比安卡-严霜凛雪"></a>比安卡-严霜凛雪</h3><p><img src="/images/post/pns-4.jpg" alt="比安卡-严霜凛雪"></p><h3 id="卡列尼娜"><a href="#卡列尼娜" class="headerlink" title="卡列尼娜"></a>卡列尼娜</h3><p><img src="/images/post/pns-1.jpg" alt="卡列尼娜"></p><h3 id="露西亚"><a href="#露西亚" class="headerlink" title="露西亚"></a>露西亚</h3><p><img src="/images/post/pns-2.jpg" alt="露西亚"></p><h3 id="里"><a href="#里" class="headerlink" title="里"></a>里</h3><p><img src="/images/post/pns-3.jpg" alt="里"></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://wiki.biligame.com/zspms/" target="_blank" rel="noopener">直达wiki</a></p><h3 id="上app-store主推了-191209"><a href="#上app-store主推了-191209" class="headerlink" title="上app store主推了 191209"></a>上app store主推了 191209</h3><p><a href="https://apps.apple.com/cn/story/id1484805266" target="_blank" rel="noopener">appstore主推</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;player-pns&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;new DPlayer({container:document.getElementById(&quot;player-pns&quot;),video:{url:&quot;http://cdnstatic.kurogame.com/pns/2.0/images/video1.mp4&quot;}})&lt;/script&gt;&lt;p&gt;《战双帕弥什》是广州库洛科技有限公司研发的一款末世科幻题材的3D动作手游。你将化身指挥官，带领人类最后的希望——仿生人形「构造体」，共同对抗被「帕弥什」病毒感染的机械大军。运用你的判断力，灵活地滑动指尖，触发不同的技能招式，在世界的终焉打出华丽一战吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="游戏" scheme="https://ghostsf.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Jrebel for android</title>
    <link href="https://ghostsf.com/jrebel-android/"/>
    <id>https://ghostsf.com/jrebel-android/</id>
    <published>2019-11-28T18:07:55.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><blockquote><p>Plugins -&gt; Manage Plugin Repositories -&gt; add</p></blockquote><p><code>http://dl.zeroturnaround.com/jrebel-android/plugins/ide-studio/updatePlugins.xml</code></p><h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><blockquote><p>Install <code>JRebel for Android</code></p></blockquote><h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><blockquote><p>Activation</p></blockquote><p><code>Group URL:http://idea.lanyus.com/UUID</code></p><p><code>Email:your email</code></p><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><blockquote><p>Run or debug by Jrebel</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;Plugins -&amp;gt; Manage Plugin Repositories -&amp;gt; add
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="AndroidStudio" scheme="https://ghostsf.com/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>善用 Android Studio 的异动管理功能</title>
    <link href="https://ghostsf.com/as-move/"/>
    <id>https://ghostsf.com/as-move/</id>
    <published>2019-11-21T14:38:15.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到一篇难得的关于Android Studio 的异动管理功能的说明文章，姑且转载分享之<br>图片还没整理好 太懒了 后续再慢慢整理 完善吧</p></blockquote><p>身为一个开发人员，每天的工作就是在不断地异动 Source Code 中度过。增加新的、修改旧的、删掉不要的，而每一个异动都会对应到特定的目的，像是为了新的需求、修改 Bug、重构程式等等。</p><p>很多时候，异动的目的在工作的过程中是混在一起的，例如开发新功能的同时，也有可能在修正之前的问题。在自己的工作环境中，这些异动混在一起通常都不会有什么问题产生。只不过这些工作的成果终究是要交付出去的，而问题总在于这些目的却不一定是在同一个时间点被交付。如果所有的异动都混在一起，要隔离出需要交付的部份，势必要花费一番工夫才能办得到。</p><p>而这样的工作要靠人工来逐个 Block、逐个 File 来分辨识，不但耗时，同时也极有可能出现疏漏。因为一个修改就有可能牵涉到十几个 Files，再加上 IDE 自动产生或管理的加一加可能就有成百上千之数。自己经手的异动都不一定能精确的掌握，更何况是数量在数倍、完全不是自己产生的内容。</p><p>人工应付不来，就得要靠工具的辅助。就如同在“ <a href="https://www.jianshu.com/p/50ab4a02c19f" target="_blank" rel="noopener">如何写好程序</a> ”一文中提到，善用工具是写好程序的功课之一。以开发 Android 时所使用的 Android Studio 来说，虽然是由 IntelliJ IDEA Community 版本进化而来，但不代表功能上就很阳春。针对本文提到的问题，其实有内建了相当方便的功能，可以协助开发者解决这类工作上的问题。</p><h2 id="Android-Studio-提供的异动管理功能"><a href="#Android-Studio-提供的异动管理功能" class="headerlink" title="Android Studio 提供的异动管理功能"></a>Android Studio 提供的异动管理功能</h2><h3 id="Changelist"><a href="#Changelist" class="headerlink" title="Changelist"></a>Changelist</h3><p>这是一个以 File 为单位，把异动内容给分门别类的功能。透过这个功能，可以把修改过的 File 进行分组。当有异动内容需要被交付时，可以直接以分好的组别为单位交付。像是要进行 Commit 时，则可以指定特定的 Changelist 来 Commit，不在分组内的 Files 则不会受影响。</p><p>要使用这个功能可以先进入 Version Control Tool Window，Menu 的位置在【View -&gt; Tool Windows -&gt; Version Control】。开启之后可以看见如下图示的内容：</p><p>在 Local Changes 的 Tab 中，可以看到有一个 <code>Default</code> 的字样，这就是 Android Studio 预先产生好的 Changelist。如果没有特别指定，所有被异动的 Files 都会被归在这个 Changelist 之下。在操作上可以使用 Tool Window 中左方的按钮来新增一个 Changelist，新增时可设定此 Changelist 为 Active，代表之后所有还没被异动的 File，在异动后都会被归到这个 Changelist 之下。</p><p>要在 Changelist 之间移动 File 也非常地直觉，可以使用拖拉项目的方式，或是在项目上按下滑鼠右键选择【Move to Another Changelist…】即可。</p><p>当要进行 Commit 时，就可以在如下的“Commit Changes”画面中，最上方的下拉清单选择对应的 Changelist。</p><p>选择不同的 Changelist 时，Changelist 的名称会预设成为 Commit Message 的内容。</p><p>由于 Changelist 是以 File 为单位，所以会有一个限制是同一个 File 不能同时归属于二个 Changelist。一旦编辑了不在 Active Changelist 中的 File，Android Studio 就会出现以下的警告：</p><p>可以看见 Tab 上的文件名变成了红色，这是 Android Studio 遇到异动冲突预设的反应，这部份可以透过点选画面中最右方的按钮来调整。</p><p>这时如果只是忘了切换 Active Changelist，可以选择【Ignore】或是【Switch changelist】。但若真的是二个不同的修改项目都异动到同一个 File，那就得选择一个适当的策略。</p><p>当修改的内容不会有交互的影响，也就是说二个修改项目的结果可以共存在同一个 File 之中，则可以选择【Move changes】把 File 移到最先要被 Commit 的 Changelist 中。</p><p>反之，修改的内容是互斥的时候，就要先保留其中一个版本、还原回修改前的状态后，再开始另一个项目的修改。这个方式在 Android Studio 中也有提供了对应的功能来达成，在这篇文章的稍后会提到。</p><p>Changelist 在使用的情境上，还可以用来区隔一定会修改，但却没有要 Commit 的 File。例如有一些程序运行时需要的配置文件，内容中记录的是 Production 的参数，在开发时就必须要进行修改才能做调试。这时就可以预先新增好一个专用的 Changelist，把这类的 Files 在修改之后归进去。未来在 Commit 时才不致一时疏忽，把开发环境的设定参数给 Commit，造成后续生成上的问题。</p><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Label 主要是作用在【VCS -&gt; Local History -&gt; Show History】的 Window 上，如下图所示：</p><p>在 Window 的左侧，可以看到第一个和第二个 History 项目中间，夹了一个 Sample Label 的文字，这个文字是使用【VCS -&gt; Local History -&gt; Put Label…】功能放上去的。</p><p>透过这个功能，可以在进行一些实验性的调整之前，先标定好目前 Source Code 状态。当调整不如预期时，就可以不用花精神去回想做了哪些的修改，再一一去做回复。有了 Label 就可以在 History 的清单中找到所标定的 Source Code 状态，使用【Revert】的功能，直接回到调整前的状态，相当地省事又有效率。</p><h3 id="Shelf"><a href="#Shelf" class="headerlink" title="Shelf"></a>Shelf</h3><p>字面上的意义就是架子，是一个用来摆放文件夹的架子。而文件夹则是前面所提到的 Changelist 的快照，所以当 Changelist 发生冲突时，就可以利用 Shelf 把 Changelist 当下的状态保留起来，等到冲突的情况解决了之后，再把原本异动的内容还原回来。</p><p>要把 Changelist 放到架子上，可以从 Menu 中选择【VCS -&gt; Shelve Changes…】。</p><p>可以由上图看到，画面和 Commit 差不多。完成之后，会在 Version Control Tool Window 中多出一个 Shelf 的 Tab，同时被 Shelve 的 Files 会回到异动前的状态。在 Shelf 的 Tab 上，可以管理 Shelve 过的项目，像是 Unshelve、Rename、Delete。</p><p>在 Unshelve 的过程中，如果没有出现内容冲突，则会自动套用 Shelf 中保留的异动状态。如果内容出现冲突时，则会显示以下的 Window，要求决定所需套用的版本：</p><p>Shelf 除了应用在工作项目的切换之外，如果所开发的 Project 有多个 Branch，在 Branch 还没有相互 Merge 之前，也可以使用 Shelf 来转移、把异动过程套用在不同的 Branch 上。这一点在异动的 Files 数量庞大时，就可以显现出效率上差别，一个批次就可以完成工作，不用再一个个 File 来比对，并且担心是否有异动的内容遗漏了。</p><h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><p>Patch 可以算是 Shelf 的外带版本，外带去哪？就是把异动的内容带出 Android Studio 的环境之外。使用 Menu 中【VCS -&gt; Create Patch…】的功能，可以把原本要新增到 Shelf 的项目，改为产生一个实体的 File。操作的画面和 Shelve Changes 一模一样，只是在按下 Window 上【Create Patch…】的按钮后，会出现以下的画面，以便指定 File 储存的位置。</p><p>基本上 Shelf 的项目和 Patch 可以互换，在 Tool Window 中 Shelf 的项目上可以触发 Create Patch 的动作，让 Shelf 的项目转成 Patch。反之，也可以在 Shelf 的 Tab 上 Import Patches 成为 Shelf 的项目。在产生 Shelf 项目和 Patch 时，还有一点最大的差异是 Patch 产生之后，并不会将内容回复到异动之前，而是维持修改后的状态。</p><p>从 Menu 中选择【VCS -&gt; Apply Patch…】后，可以把 Patch 的内容套用回目前的工作环境中，套用的过程和 Shelf 差不多，遇到内容冲突时也同样会出现相同的画面，来决定要选用的版本。</p><p>在应用上，Shelf 的项目能做的 Patch 都能做，除此之外 Patch 还可以用来在不同的 Android Studio 环境之间移转。可以用来将工作的状态由公司的环境中移至家中的环境，以便在离开公司之后仍可接续未完成的部份。或者是可以把 Patch 交给不同的开发人员，用来进行协同合作、Review Code 等工作。</p><p>和版本控管工具的比较<br>如果在开发时使用 Git 做为版本控管的工具，其实以上的功能 Git 大多都可以做到。Android Studio 则是在原有的版本控管机制之外，提供不同的选项，对于不熟悉版本控管工具的人来说有莫大的帮助。而对于用惯了原本工具的人来说，要怎么使用还是得看每个人的习惯、对工具的喜好程度。只不过在面对不同的情况之下，多学会一种工具的使用，在应对的策略上也能产生更多的弹性。</p><p>作者：<em>WZ</em></p><p>链接：<a href="https://www.jianshu.com/p/f66e3ad097ad" target="_blank" rel="noopener">https://www.jianshu.com/p/f66e3ad097ad</a></p><p>来源：简书</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;看到一篇难得的关于Android Studio 的异动管理功能的说明文章，姑且转载分享之&lt;br&gt;图片还没整理好 太懒了 后续再慢慢整理 完善吧&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;身为一个开发人员，每天的工作就是在不断地异动 Source Code
      
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="AndroidStudio" scheme="https://ghostsf.com/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>Could not retrieve transation read-only status server &amp;&amp; Communications link failure 异常</title>
    <link href="https://ghostsf.com/mybatis-mysql-error/"/>
    <id>https://ghostsf.com/mybatis-mysql-error/</id>
    <published>2019-11-04T10:46:36.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<p>上线的项目遇到一个问题。异常信息如下：</p><p>``</p><p>SQLException: Could not retrieve transation read-only status server</p><p>……</p><p>Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure</p><p>``</p><p>这两个异常问题，可以联想到的常见问题，无非是事务的问题或者是数据库连接的问题了。</p><p>事务方面 检查了mysql的事务隔离级别：</p><p><code>SHOW VARIABLES LIKE &#39;%iso%&#39;;</code></p><p>返回结果是：</p><p><code>READ-COMMITTED</code></p><blockquote><p>当数据库隔离级别为REPEATABLE-READ时，查询一个select语句也算是事物的开始。</p></blockquote><p>那这就不是这个原因导致的了。</p><p>再看连接的问题，</p><p>看一下数据库时间相关的设置：</p><p><code>show variables like &#39;%timeout%&#39;</code></p><p>返回结果是：</p><p>``</p><p>connect_timeout 10</p><p>delayed_insert_timeout 300</p><p>failover_resend_timeout</p><p>have_statement_timeout YES</p><p>innodb_flush_log_at_timeout 1</p><p>innodb_lock_wait_timeout 50</p><p>innodb_rollback_on_timeout OFF</p><p>interactive_timeout 7200</p><p>lock_wait_timeout 31536000</p><p>net_read_timeout 30</p><p>net_write_timeout 60</p><p>rocksdb_io_write_timeout 0</p><p>rocksdb_lock_wait_timeout 2</p><p>rpl_semi_sync_master_timeout 10000</p><p>rpl_semi_sync_slave_kill_conn_timeout 5</p><p>rpl_stop_slave_timeout 31536000</p><p>slave_net_timeout 60</p><p>thread_pool_idle_timeout 60</p><p>tokudb_last_lock_timeout</p><p>tokudb_lock_timeout 4000</p><p>tokudb_lock_timeout_debug 1</p><p>wait_timeout 7200</p><p>``</p><p>这也没什么问题。再多也不合理。</p><p>那可能就是本事mysql的驱动的问题了。</p><p>检查了下版本。再查了下，对应版本关系。</p><p><a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-versions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-versions.html</a></p><p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-versions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-versions.html</a></p><p>官网瞄一眼</p><p>emmm，看到5.1的版本里有个Note</p><blockquote><p>MySQL Connector/J 8.0 is highly recommended for use with MySQL Server 8.0, 5.7, and 5.6. Please upgrade to MySQL Connector/J 8.0.</p></blockquote><p>那还说啥，升级到8.0咯</p><p>然后更新升级了上去，然后没问题了 …</p><p>Happy ending.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上线的项目遇到一个问题。异常信息如下：&lt;/p&gt;&lt;p&gt;``&lt;/p&gt;&lt;p&gt;SQLException: Could not retrieve transation read-only status server&lt;/p&gt;&lt;p&gt;……&lt;/p&gt;&lt;p&gt;Caused by: com.mysq
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="mysql" scheme="https://ghostsf.com/tags/mysql/"/>
    
      <category term="mybatis" scheme="https://ghostsf.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>nginx-proxy-read-responseheader-fail</title>
    <link href="https://ghostsf.com/nginx-proxy-read-responseheader-fail/"/>
    <id>https://ghostsf.com/nginx-proxy-read-responseheader-fail/</id>
    <published>2019-07-22T12:04:36.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<p>反向代理 recv() failed (104: Connection reset by peer) while reading response header from upstream错误</p><blockquote><p>原因就是请求的头文件过大导致502错误</p></blockquote><p><strong>解决方法就是提高头的缓存</strong></p><p>``<br>http {</p><pre><code>client_header_buffer_size 5m;location / {proxy_buffer_size 128k;proxy_busy_buffers_size 192k;proxy_buffers 4 192k;}</code></pre><p>}<br>``</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反向代理 recv() failed (104: Connection reset by peer) while reading response header from upstream错误&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;原因就是请求的头文件过大导致502错误&lt;/p
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="nginx" scheme="https://ghostsf.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>代码可读性规范</title>
    <link href="https://ghostsf.com/code-readability/"/>
    <id>https://ghostsf.com/code-readability/</id>
    <published>2019-05-06T09:22:07.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、可读性的重要性"><a href="#一、可读性的重要性" class="headerlink" title="一、可读性的重要性"></a>一、可读性的重要性</h1><p>编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。</p><p>可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。</p><p>只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。</p><a id="more"></a><h1 id="二、用名字表达代码含义"><a href="#二、用名字表达代码含义" class="headerlink" title="二、用名字表达代码含义"></a>二、用名字表达代码含义</h1><p>一些比较有表达力的单词：</p><table><thead><tr><th align="center">单词</th><th>可替代单词</th></tr></thead><tbody><tr><td align="center">send</td><td>deliver、dispatch、announce、distribute、route</td></tr><tr><td align="center">find</td><td>search、extract、locate、recover</td></tr><tr><td align="center">start</td><td>launch、create、begin、open</td></tr><tr><td align="center">make</td><td>create、set up、build、generate、compose、add、new</td></tr></tbody></table><p>使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高。</p><p>为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。</p><h1 id="三、名字不能带来歧义"><a href="#三、名字不能带来歧义" class="headerlink" title="三、名字不能带来歧义"></a>三、名字不能带来歧义</h1><p>起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。</p><p>布尔相关的命名加上 is、can、should、has 等前缀。</p><ul><li>用 min、max 表示数量范围；</li><li>用 first、last 表示访问空间的包含范围；</li></ul><div align="center"><img src="pics/7d97dde0-0695-4707-bb68-e6c13a2e1b45.png" width="200px"></div><br><ul><li>begin、end 表示访问空间的排除范围，即 end 不包含尾部。</li></ul><div align="center"><img src="pics/d85870db-f28c-48c3-9d24-85a36fda5e51.png" width="200px"></div><br><h1 id="四、良好的代码风格"><a href="#四、良好的代码风格" class="headerlink" title="四、良好的代码风格"></a>四、良好的代码风格</h1><p>适当的空行和缩进。</p><p>排列整齐的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;   <span class="comment">// 注释</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">11</span>;  <span class="comment">// 注释</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">111</span>; <span class="comment">// 注释</span></span><br></pre></td></tr></table></figure><p>语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致。</p><h1 id="五、为何编写注释"><a href="#五、为何编写注释" class="headerlink" title="五、为何编写注释"></a>五、为何编写注释</h1><p>阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是并不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。</p><p>不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。</p><p>可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。</p><p>注释用来提醒一些特殊情况。</p><p>用 TODO 等做标记：</p><table><thead><tr><th>标记</th><th>用法</th></tr></thead><tbody><tr><td>TODO</td><td>待做</td></tr><tr><td>FIXME</td><td>待修复</td></tr><tr><td>HACK</td><td>粗糙的解决方案</td></tr><tr><td>XXX</td><td>危险！这里有重要的问题</td></tr></tbody></table><h1 id="六、如何编写注释"><a href="#六、如何编写注释" class="headerlink" title="六、如何编写注释"></a>六、如何编写注释</h1><p>尽量简洁明了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The first String is student's name</span></span><br><span class="line"><span class="comment">// The Second Integer is student's score</span></span><br><span class="line">Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student's name -&gt; Student's score</span></span><br><span class="line">Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>添加测试用例来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Example: add(1, 2), return 3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用专业名词来缩短概念上的解释，比如用设计模式名来说明代码。</p><h1 id="七、提高控制流的可读性"><a href="#七、提高控制流的可读性" class="headerlink" title="七、提高控制流的可读性"></a>七、提高控制流的可读性</h1><p>条件表达式中，左侧是变量，右侧是常数。比如下面第一个语句正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">10</span> &gt; len)</span><br></pre></td></tr></table></figure><p>只有在逻辑简单的情况下使用 ? : 三目运算符来使代码更紧凑，否则应该拆分成 if / else；</p><p>do / while 的条件放在后面，不够简单明了，并且会有一些迷惑的地方，最好使用 while 来代替。</p><p>如果只有一个 goto 目标，那么 goto 尚且还能接受，但是过于复杂的 goto 会让代码可读性特别差，应该避免使用 goto。</p><p>在嵌套的循环中，用一些 return 语句往往能减少嵌套的层数。</p><h1 id="八、拆分长表达式"><a href="#八、拆分长表达式" class="headerlink" title="八、拆分长表达式"></a>八、拆分长表达式</h1><p>长表达式的可读性很差，可以引入一些解释变量从而拆分表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> line.split(<span class="string">':'</span>)[<span class="number">0</span>].strip() == <span class="string">"root"</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username = line.split(<span class="string">':'</span>)[<span class="number">0</span>].strip()</span><br><span class="line"><span class="keyword">if</span> username == <span class="string">"root"</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>使用摩根定理简化一些逻辑表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a &amp;&amp; !b) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(a || b)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、变量与可读性"><a href="#九、变量与可读性" class="headerlink" title="九、变量与可读性"></a>九、变量与可读性</h1><p><strong>去除控制流变量</strong> 。在循环中通过使用 break 或者 return 可以减少控制流变量的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/* condition */</span> &amp;&amp; !done) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( ... ) &#123;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="comment">/* condition */</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( ... ) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>减小变量作用域</strong> 。作用域越小，越容易定位到变量所有使用的地方。</p><p>JavaScript 可以用闭包减小作用域。以下代码中 submit_form 是函数变量，submitted 变量控制函数不会被提交两次。第一个实现中 submitted 是全局变量，第二个实现把 submitted 放到匿名函数中，从而限制了起作用域范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">submitted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> submit_form = <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    submitted = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> submit_form = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> submitted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(submitted) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        submitted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());  <span class="comment">// () 使得外层匿名函数立即执行</span></span><br></pre></td></tr></table></figure><p>JavaScript 中没有用 var 声明的变量都是全局变量，而全局变量很容易造成迷惑，因此应当总是用 var 来声明变量。</p><p>变量定义的位置应当离它使用的位置最近。</p><p><strong>实例解析</strong></p><p>在一个网页中有以下文本输入字段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input1"</span> <span class="attr">value</span> = <span class="string">"a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input2"</span> <span class="attr">value</span> = <span class="string">"b"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input3"</span> <span class="attr">value</span> = <span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input4"</span> <span class="attr">value</span> = <span class="string">"d"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在要接受一个字符串并把它放到第一个空的 input 字段中，初始实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setFirstEmptyInput = <span class="function"><span class="keyword">function</span>(<span class="params">new_alue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span> + i);</span><br><span class="line">    <span class="keyword">while</span> (elem != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem.value === <span class="string">''</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        elem = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found) elem.value = new_value;</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现有以下问题：</p><ul><li>found 可以去除；</li><li>elem 作用域过大；</li><li>可以用 for 循环代替 while 循环；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setFirstEmptyInput = <span class="function"><span class="keyword">function</span>(<span class="params">new_value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (elem === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (elem.value === <span class="string">''</span>) &#123;</span><br><span class="line">            elem.value = new_value;</span><br><span class="line">            <span class="keyword">return</span> elem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="十、抽取函数"><a href="#十、抽取函数" class="headerlink" title="十、抽取函数"></a>十、抽取函数</h1><p>工程学就是把大问题拆分成小问题再把这些问题的解决方案放回一起。</p><p>首先应该明确一个函数的高层次目标，然后对于不是直接为了这个目标工作的代码，抽取出来放到独立的函数中。</p><p>介绍性的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findClostElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clostIdx;</span><br><span class="line">    <span class="keyword">int</span> clostDist = Interger.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = ...;</span><br><span class="line">        <span class="keyword">int</span> y = ...;</span><br><span class="line">        <span class="keyword">int</span> z = ...;</span><br><span class="line">        <span class="keyword">int</span> value = x * y * z;</span><br><span class="line">        <span class="keyword">int</span> dist = Math.sqrt(Math.pow(value, <span class="number">2</span>), Math.pow(arr[i], <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; clostDist) &#123;</span><br><span class="line">            clostIdx = i;</span><br><span class="line">            clostDist = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clostIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中循环部分主要计算距离，这部分不属于代码高层次目标，高层次目标是寻找最小距离的值，因此可以把这部分代替提取到独立的函数中。这样做也带来一个额外的好处有：可以单独进行测试、可以快速找到程序错误并修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClostElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clostIdx;</span><br><span class="line">    <span class="keyword">int</span> clostDist = Interger.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> dist = computDist(arr, i);</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; clostDist) &#123;</span><br><span class="line">            clostIdx = i;</span><br><span class="line">            clostDist = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clostIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是函数抽取的越多越好，如果抽取过多，在阅读代码的时候可能需要不断跳来跳去。只有在当前函数不需要去了解某一块代码细节而能够表达其内容时，把这块代码抽取成子函数才是好的。</p><p>函数抽取也用于减小代码的冗余。</p><h1 id="十一、一次只做一件事"><a href="#十一、一次只做一件事" class="headerlink" title="十一、一次只做一件事"></a>十一、一次只做一件事</h1><p>只做一件事的代码很容易让人知道其要做的事；</p><p>基本流程：列出代码所做的所有任务；把每个任务拆分到不同的函数，或者不同的段落。</p><h1 id="十二、用自然语言表述代码"><a href="#十二、用自然语言表述代码" class="headerlink" title="十二、用自然语言表述代码"></a>十二、用自然语言表述代码</h1><p>先用自然语言书写代码逻辑，也就是伪代码，然后再写代码，这样代码逻辑会更清晰。</p><h1 id="十三、减少代码量"><a href="#十三、减少代码量" class="headerlink" title="十三、减少代码量"></a>十三、减少代码量</h1><p>不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的。</p><p>多用标准库实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、可读性的重要性&quot;&gt;&lt;a href=&quot;#一、可读性的重要性&quot; class=&quot;headerlink&quot; title=&quot;一、可读性的重要性&quot;&gt;&lt;/a&gt;一、可读性的重要性&lt;/h1&gt;&lt;p&gt;编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。&lt;/p&gt;&lt;p&gt;可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。&lt;/p&gt;&lt;p&gt;只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="代码规范" scheme="https://ghostsf.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>git-tips</title>
    <link href="https://ghostsf.com/git-tips/"/>
    <id>https://ghostsf.com/git-tips/</id>
    <published>2019-04-21T15:56:55.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git的奇技淫巧"><a href="#Git的奇技淫巧" class="headerlink" title="Git的奇技淫巧:"></a>Git的奇技淫巧:</h1><blockquote><p>Git常用命令集合</p></blockquote><p>Git是一个 “分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过 “回撤” 这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用 “回撤” 是找不回来的。而 “版本管理工具” 能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。</p><p>下面的内容就是列举了常用的 Git 命令和一些小技巧，可以通过 “页面内查找” 的方式进行快速查询：<code>Ctrl/Command+f</code>。</p><h2 id="开卷必读"><a href="#开卷必读" class="headerlink" title="开卷必读"></a>开卷必读</h2><p><em>如果之前未使用过 Git，可以学习 <a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">Git 小白教程</a>入门</em></p><ol><li><strong>一定要先测试命令的效果后</strong>，再用于工作环境中，以防造成不能弥补的后果！<strong>到时候别拿着砍刀来找我</strong></li><li>所有的命令都在<code>git version 2.7.4 (Apple Git-66)</code>下测试通过</li><li>统一概念：<ul><li>工作区：改动（增删文件和内容）</li><li>暂存区：输入命令：<code>git add 改动的文件名</code>，此次改动就放到了 ‘暂存区’</li><li>本地仓库(简称：本地)：输入命令：<code>git commit 此次修改的描述</code>，此次改动就放到了 ’本地仓库’，每个 commit，我叫它为一个 ‘版本’。</li><li>远程仓库(简称：远程)：输入命令：<code>git push 远程仓库</code>，此次改动就放到了 ‘远程仓库’（GitHub 等)</li><li>commit-id：输出命令：<code>git log</code>，最上面那行 <code>commit xxxxxx</code>，后面的字符串就是 commit-id<a id="more"></a></li></ul></li></ol><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#展示帮助信息">展示帮助信息</a></li><li><a href="#回到远程仓库的状态">回到远程仓库的状态</a></li><li><a href="#重设第一个-commit">重设第一个commit</a></li><li><a href="#展示工作区和暂存区的不同">展示工作区和暂存区的不同</a></li><li><a href="#展示暂存区和最近版本的不同">展示暂存区和最近版本的不同</a></li><li><a href="#展示暂存区工作区和最近版本的不同">展示暂存区、工作区和最近版本的不同</a></li><li><a href="#快速切换到上一个分支">快速切换到上一个分支</a></li><li><a href="#删除已经合并到-master-的分支">删除已经合并到 master 的分支</a></li><li><a href="#展示本地分支关联远程仓库的情况">展示本地分支关联远程仓库的情况</a></li><li><a href="#关联远程分支">关联远程分支</a></li><li><a href="#列出所有远程分支">列出所有远程分支</a></li><li><a href="#列出本地和远程分支">列出本地和远程分支</a></li><li><a href="#创建并切换到本地分支">创建并切换到本地分支</a></li><li><a href="#从远程分支中创建并切换到本地分支">从远程分支中创建并切换到本地分支</a></li><li><a href="#删除本地分支">删除本地分支</a></li><li><a href="#删除远程分支">删除远程分支</a></li><li><a href="#重命名本地分支">重命名本地分支</a></li><li><a href="#查看标签">查看标签</a></li><li><a href="#查看标签详细信息">查看标签详细信息</a></li><li><a href="#本地创建标签">本地创建标签</a></li><li><a href="#推送标签到远程仓库">推送标签到远程仓库</a></li><li><a href="#删除本地标签">删除本地标签</a></li><li><a href="#删除远程标签">删除远程标签</a></li><li><a href="#切回到某个标签">切回到某个标签</a></li><li><a href="#放弃工作区的修改">放弃工作区的修改</a></li><li><a href="#恢复删除的文件">恢复删除的文件</a></li><li><a href="#以新增一个-commit-的方式还原某一个-commit-的修改">以新增一个 commit 的方式还原某一个 commit 的修改</a></li><li><a href="#回到某个-commit-的状态并删除后面的-commit">回到某个 commit 的状态，并删除后面的 commit</a></li><li><a href="#修改上一个-commit-的描述">修改上一个 commit 的描述</a></li><li><a href="#查看-commit-历史">查看 commit 历史</a></li><li><a href="#显示本地更新过-head-的-git-命令记录">显示本地更新过 HEAD 的 git 命令记录</a></li><li><a href="#修改作者名">修改作者名</a></li><li><a href="#修改远程仓库的-url">修改远程仓库的 url</a></li><li><a href="#增加远程仓库">增加远程仓库</a></li><li><a href="#列出所有远程仓库">列出所有远程仓库</a></li><li><a href="#查看两个星期内的改动">查看两个星期内的改动</a></li><li><a href="#把-A-分支的某一个-commit-放到-B-分支上">把 A 分支的某一个 commit，放到 B 分支上</a></li><li><a href="#给-git-命令起别名">给 git 命令起别名</a></li><li><a href="#存储当前的修改但不用提交-commit">存储当前的修改，但不用提交 commit</a></li><li><a href="#保存当前状态包括-untracked-的文件">保存当前状态，包括 untracked 的文件</a></li><li><a href="#展示所有-stashes">展示所有 stashes</a></li><li><a href="#回到某个-stash-的状态">回到某个 stash 的状态</a></li><li><a href="#回到最后一个-stash-的状态并删除这个-stash">回到最后一个 stash 的状态，并删除这个 stash</a></li><li><a href="#删除所有的-stash">删除所有的 stash</a></li><li><a href="#从-stash-中拿出某个文件的修改">从 stash 中拿出某个文件的修改</a></li><li><a href="#展示所有-tracked-的文件">展示所有 tracked 的文件</a></li><li><a href="#展示所有-untracked-的文件">展示所有 untracked 的文件</a></li><li><a href="#展示所有忽略的文件">展示所有忽略的文件</a></li><li><a href="#强制删除-untracked-的文件">强制删除 untracked 的文件</a></li><li><a href="#强制删除-untracked-的目录">强制删除 untracked 的目录</a></li><li><a href="#展示简化的-commit-历史">展示简化的 commit 历史</a></li><li><a href="#查看某段代码是谁写的">查看某段代码是谁写的</a></li><li><a href="#把某一个分支到导出成一个文件">把某一个分支到导出成一个文件</a></li><li><a href="#从包中导入分支">从包中导入分支</a></li><li><a href="#执行-rebase-之前自动-stash">执行 rebase 之前自动 stash</a></li><li><a href="#从远程仓库根据-ID-拉下某一状态-到本地分支">从远程仓库根据 ID，拉下某一状态，到本地分支</a></li><li><a href="#详细展示一行中的修改">详细展示一行中的修改</a></li><li><a href="#清除-gitignore-文件中记录的文件">清除 <code>.gitignore</code> 文件中记录的文件</a></li><li><a href="#展示所有-alias-和-configs">展示所有 alias 和 configs</a></li><li><a href="#展示忽略的文件">展示忽略的文件</a></li><li><a href="#commit-历史中显示-Branch1-有的但是-Branch2-没有-commit">commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</a></li><li><a href="#在-commit-log-中显示-GPG-签名">在 commit log 中显示 GPG 签名</a></li><li><a href="#删除全局设置">删除全局设置</a></li><li><a href="#新建并切换到新分支上同时这个分支没有任何-commit">新建并切换到新分支上，同时这个分支没有任何 commit</a></li><li><a href="#展示任意分支某一文件的内容">展示任意分支某一文件的内容</a></li><li><a href="#clone-下来指定的单一分支">clone 下来指定的单一分支</a></li><li><a href="#忽略某个文件的改动">忽略某个文件的改动</a></li><li><a href="#忽略文件的权限变化">忽略文件的权限变化</a></li><li><a href="#以最后提交的顺序列出所有-Git-分支">以最后提交的顺序列出所有 Git 分支</a></li><li><a href="#在-commit-log-中查找相关内容">在 commit log 中查找相关内容</a></li><li><a href="#把暂存区的指定-file-放到工作区中">把暂存区的指定 file 放到工作区中</a></li><li><a href="#强制推送">强制推送</a></li><li><a href="#一图详解">一图详解</a></li><li><a href="#优雅的提交Commit信息">优雅的提交Commit信息</a></li><li><a href="#联系我">联系我</a></li></ul><h2 id="展示帮助信息"><a href="#展示帮助信息" class="headerlink" title="展示帮助信息"></a>展示帮助信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> -g</span><br></pre></td></tr></table></figure><p>The command output as below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">The common Git guides are:</span><br><span class="line">   attributes          Defining attributes per path</span><br><span class="line">   cli                 Git command-line interface and conventions</span><br><span class="line">   core-tutorial       A Git core tutorial for developers</span><br><span class="line">   cvs-migration       Git for CVS users</span><br><span class="line">   diffcore            Tweaking diff output</span><br><span class="line">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class="line">   glossary            A Git Glossary</span><br><span class="line">   hooks               Hooks used by Git</span><br><span class="line">   ignore              Specifies intentionally untracked files to ignore</span><br><span class="line">   modules             Defining submodule properties</span><br><span class="line">   namespaces          Git namespaces</span><br><span class="line">   repository-layout    Git Repository Layout</span><br><span class="line">   revisions           Specifying revisions and ranges for Git</span><br><span class="line">   tutorial            A tutorial introduction to Git</span><br><span class="line">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class="line">   workflows           An overview of recommended workflows with Git</span><br><span class="line"></span><br><span class="line">&#39;git help -a&#39; and &#39;git help -g&#39; list available subcommands and some concept guides. See &#39;git help &lt;command&gt;&#39; or &#39;git help &lt;concept&gt;&#39; to read about a specific subcommand or concept.</span><br></pre></td></tr></table></figure><h2 id="回到远程仓库的状态"><a href="#回到远程仓库的状态" class="headerlink" title="回到远程仓库的状态"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master</span><br></pre></td></tr></table></figure><h2 id="重设第一个-commit"><a href="#重设第一个-commit" class="headerlink" title="重设第一个 commit"></a>重设第一个 commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的 commit</strong>，这样就可以重新提交第一个 commit 了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-ref -d HEAD</span><br></pre></td></tr></table></figure><h2 id="展示工作区和暂存区的不同"><a href="#展示工作区和暂存区的不同" class="headerlink" title="展示工作区和暂存区的不同"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的 different (不同)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>还可以展示本地仓库中任意两个 commit 之间的文件变动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit-id&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="展示暂存区和最近版本的不同"><a href="#展示暂存区和最近版本的不同" class="headerlink" title="展示暂存区和最近版本的不同"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本 (commit) 的 different (不同)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><h2 id="展示暂存区、工作区和最近版本的不同"><a href="#展示暂存区、工作区和最近版本的不同" class="headerlink" title="展示暂存区、工作区和最近版本的不同"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本 (commit) 的 different (不同)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><h2 id="快速切换到上一个分支"><a href="#快速切换到上一个分支" class="headerlink" title="快速切换到上一个分支"></a>快速切换到上一个分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h2 id="删除已经合并到-master-的分支"><a href="#删除已经合并到-master-的分支" class="headerlink" title="删除已经合并到 master 的分支"></a>删除已经合并到 master 的分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master | grep -v <span class="string">'^\*\|  master'</span> | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure><h2 id="展示本地分支关联远程仓库的情况"><a href="#展示本地分支关联远程仓库的情况" class="headerlink" title="展示本地分支关联远程仓库的情况"></a>展示本地分支关联远程仓库的情况</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>关联之后，<code>git branch -vv</code> 就可以展示关联的远程分支名了，同时推送到远程仓库直接：<code>git push</code>，不需要指定远程仓库了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/mybranch</span><br></pre></td></tr></table></figure><p>或者在 push 时加上 <code>-u</code> 参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin/mybranch -u</span><br></pre></td></tr></table></figure><h2 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h2><p>-r 参数相当于：remote</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a 参数相当于：all</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="从远程分支中创建并切换到本地分支"><a href="#从远程分支中创建并切换到本地分支" class="headerlink" title="从远程分支中创建并切换到本地分支"></a>从远程分支中创建并切换到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;<span class="built_in">local</span>-branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>展示当前分支的最近的 tag</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --tags --abbrev=0</span><br></pre></td></tr></table></figure><h2 id="查看标签详细信息"><a href="#查看标签详细信息" class="headerlink" title="查看标签详细信息"></a>查看标签详细信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -ln</span><br></pre></td></tr></table></figure><h2 id="本地创建标签"><a href="#本地创建标签" class="headerlink" title="本地创建标签"></a>本地创建标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;version-number&gt;</span><br></pre></td></tr></table></figure><p>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a &lt;version-number&gt; -m <span class="string">"v1.0 发布(描述)"</span> &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;<span class="built_in">local</span>-version-number&gt;</span><br></pre></td></tr></table></figure><p>一次性推送所有标签，同步到远程仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h2 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tag-name&gt;</span><br></pre></td></tr></table></figure><h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><p>删除远程标签需要<strong>先删除本地标签</strong>，再执行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tag-name&gt;</span><br></pre></td></tr></table></figure><h2 id="切回到某个标签"><a href="#切回到某个标签" class="headerlink" title="切回到某个标签"></a>切回到某个标签</h2><p>一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure><h2 id="放弃工作区的修改"><a href="#放弃工作区的修改" class="headerlink" title="放弃工作区的修改"></a>放弃工作区的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;file-name&gt;</span><br></pre></td></tr></table></figure><p>放弃所有修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h2 id="恢复删除的文件"><a href="#恢复删除的文件" class="headerlink" title="恢复删除的文件"></a>恢复删除的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rev-list -n 1 HEAD -- &lt;file_path&gt; <span class="comment">#得到 deleting_commit</span></span><br><span class="line"></span><br><span class="line">git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; <span class="comment">#回到删除文件 deleting_commit 之前的状态</span></span><br></pre></td></tr></table></figure><h2 id="以新增一个-commit-的方式还原某一个-commit-的修改"><a href="#以新增一个-commit-的方式还原某一个-commit-的修改" class="headerlink" title="以新增一个 commit 的方式还原某一个 commit 的修改"></a>以新增一个 commit 的方式还原某一个 commit 的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="回到某个-commit-的状态，并删除后面的-commit"><a href="#回到某个-commit-的状态，并删除后面的-commit" class="headerlink" title="回到某个 commit 的状态，并删除后面的 commit"></a>回到某个 commit 的状态，并删除后面的 commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit-id&gt;  <span class="comment">#默认就是-mixed参数。</span></span><br><span class="line"></span><br><span class="line">git reset –mixed HEAD^  <span class="comment">#回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span></span><br><span class="line"></span><br><span class="line">git reset –soft HEAD~3  <span class="comment">#回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可  </span></span><br><span class="line"></span><br><span class="line">git reset –hard &lt;commit-id&gt;  <span class="comment">#彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span></span><br></pre></td></tr></table></figure><h2 id="修改上一个-commit-的描述"><a href="#修改上一个-commit-的描述" class="headerlink" title="修改上一个 commit 的描述"></a>修改上一个 commit 的描述</h2><p>如果暂存区有改动，同时也会将暂存区的改动提交到上一个 commit</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="查看-commit-历史"><a href="#查看-commit-历史" class="headerlink" title="查看 commit 历史"></a>查看 commit 历史</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="查看某段代码是谁写的"><a href="#查看某段代码是谁写的" class="headerlink" title="查看某段代码是谁写的"></a>查看某段代码是谁写的</h2><p>blame 的意思为‘责怪’，你懂的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h2 id="显示本地更新过-HEAD-的-git-命令记录"><a href="#显示本地更新过-HEAD-的-git-命令记录" class="headerlink" title="显示本地更新过 HEAD 的 git 命令记录"></a>显示本地更新过 HEAD 的 git 命令记录</h2><p>每次更新了 HEAD 的 git 命令比如 commint、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。<br>这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author=<span class="string">'Author Name &lt;email@address.com&gt;'</span></span><br></pre></td></tr></table></figure><h2 id="修改远程仓库的-url"><a href="#修改远程仓库的-url" class="headerlink" title="修改远程仓库的 url"></a>修改远程仓库的 url</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h2 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git whatchanged --since=<span class="string">'2 weeks ago'</span></span><br></pre></td></tr></table></figure><h2 id="把-A-分支的某一个-commit，放到-B-分支上"><a href="#把-A-分支的某一个-commit，放到-B-分支上" class="headerlink" title="把 A 分支的某一个 commit，放到 B 分支上"></a>把 A 分支的某一个 commit，放到 B 分支上</h2><p>这个过程需要 <code>cherry-pick</code> 命令，<a href="http://sg552.iteye.com/blog/1300713#bc2367928" target="_blank" rel="noopener">参考</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="给-git-命令起别名"><a href="#给-git-命令起别名" class="headerlink" title="给 git 命令起别名"></a>给 git 命令起别名</h2><p>简化命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global <span class="built_in">alias</span>.&lt;handle&gt; &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">比如：git status 改成 git st，这样可以简化命令</span><br><span class="line"></span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><h2 id="存储当前的修改，但不用提交-commit"><a href="#存储当前的修改，但不用提交-commit" class="headerlink" title="存储当前的修改，但不用提交 commit"></a>存储当前的修改，但不用提交 commit</h2><p>详解可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="noopener">廖雪峰老师的 git 教程</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><h2 id="保存当前状态，包括-untracked-的文件"><a href="#保存当前状态，包括-untracked-的文件" class="headerlink" title="保存当前状态，包括 untracked 的文件"></a>保存当前状态，包括 untracked 的文件</h2><p>untracked 文件：新建的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash -u</span><br></pre></td></tr></table></figure><h2 id="展示所有-stashes"><a href="#展示所有-stashes" class="headerlink" title="展示所有 stashes"></a>展示所有 stashes</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><h2 id="回到某个-stash-的状态"><a href="#回到某个-stash-的状态" class="headerlink" title="回到某个 stash 的状态"></a>回到某个 stash 的状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply &lt;stash@&#123;n&#125;&gt;</span><br></pre></td></tr></table></figure><h2 id="回到最后一个-stash-的状态，并删除这个-stash"><a href="#回到最后一个-stash-的状态，并删除这个-stash" class="headerlink" title="回到最后一个 stash 的状态，并删除这个 stash"></a>回到最后一个 stash 的状态，并删除这个 stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h2 id="删除所有的-stash"><a href="#删除所有的-stash" class="headerlink" title="删除所有的 stash"></a>删除所有的 stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h2 id="从-stash-中拿出某个文件的修改"><a href="#从-stash-中拿出某个文件的修改" class="headerlink" title="从 stash 中拿出某个文件的修改"></a>从 stash 中拿出某个文件的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt;</span><br></pre></td></tr></table></figure><h2 id="展示所有-tracked-的文件"><a href="#展示所有-tracked-的文件" class="headerlink" title="展示所有 tracked 的文件"></a>展示所有 tracked 的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -t</span><br></pre></td></tr></table></figure><h2 id="展示所有-untracked-的文件"><a href="#展示所有-untracked-的文件" class="headerlink" title="展示所有 untracked 的文件"></a>展示所有 untracked 的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others</span><br></pre></td></tr></table></figure><h2 id="展示所有忽略的文件"><a href="#展示所有忽略的文件" class="headerlink" title="展示所有忽略的文件"></a>展示所有忽略的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others -i --exclude-standard</span><br></pre></td></tr></table></figure><h2 id="强制删除-untracked-的文件"><a href="#强制删除-untracked-的文件" class="headerlink" title="强制删除 untracked 的文件"></a>强制删除 untracked 的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。<code>clean</code> 命令，<strong>注意两点</strong>：</p><ol><li>clean 后，删除的文件无法找回</li><li>不会影响 tracked 的文件的改动，只会删除 untracked 的文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean &lt;file-name&gt; -f</span><br></pre></td></tr></table></figure><h2 id="强制删除-untracked-的目录"><a href="#强制删除-untracked-的目录" class="headerlink" title="强制删除 untracked 的目录"></a>强制删除 untracked 的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除 untracked 的文件。详情见上一条</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean &lt;directory-name&gt; -df</span><br></pre></td></tr></table></figure><h2 id="展示简化的-commit-历史"><a href="#展示简化的-commit-历史" class="headerlink" title="展示简化的 commit 历史"></a>展示简化的 commit 历史</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --graph --decorate --all</span><br></pre></td></tr></table></figure><h2 id="把某一个分支到导出成一个文件"><a href="#把某一个分支到导出成一个文件" class="headerlink" title="把某一个分支到导出成一个文件"></a>把某一个分支到导出成一个文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="从包中导入分支"><a href="#从包中导入分支" class="headerlink" title="从包中导入分支"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面 <code>git bundle create</code> 命令导出的内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="执行-rebase-之前自动-stash"><a href="#执行-rebase-之前自动-stash" class="headerlink" title="执行 rebase 之前自动 stash"></a>执行 rebase 之前自动 stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --autostash</span><br></pre></td></tr></table></figure><h2 id="从远程仓库根据-ID，拉下某一状态，到本地分支"><a href="#从远程仓库根据-ID，拉下某一状态，到本地分支" class="headerlink" title="从远程仓库根据 ID，拉下某一状态，到本地分支"></a>从远程仓库根据 ID，拉下某一状态，到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="详细展示一行中的修改"><a href="#详细展示一行中的修改" class="headerlink" title="详细展示一行中的修改"></a>详细展示一行中的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --word-diff</span><br></pre></td></tr></table></figure><h2 id="清除-gitignore-文件中记录的文件"><a href="#清除-gitignore-文件中记录的文件" class="headerlink" title="清除 gitignore 文件中记录的文件"></a>清除 gitignore 文件中记录的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -X -f</span><br></pre></td></tr></table></figure><h2 id="展示所有-alias-和-configs"><a href="#展示所有-alias-和-configs" class="headerlink" title="展示所有 alias 和 configs"></a>展示所有 alias 和 configs</h2><p><strong>注意：</strong> config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --list (当前目录)</span><br><span class="line">git config --global --list (全局)</span><br></pre></td></tr></table></figure><h2 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status --ignored</span><br></pre></td></tr></table></figure><h2 id="commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit"><a href="#commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit" class="headerlink" title="commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit"></a>commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> Branch1 ^Branch2</span><br></pre></td></tr></table></figure><h2 id="在-commit-log-中显示-GPG-签名"><a href="#在-commit-log-中显示-GPG-签名" class="headerlink" title="在 commit log 中显示 GPG 签名"></a>在 commit log 中显示 GPG 签名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --show-signature</span><br></pre></td></tr></table></figure><h2 id="删除全局设置"><a href="#删除全局设置" class="headerlink" title="删除全局设置"></a>删除全局设置</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> &lt;entry-name&gt;</span><br></pre></td></tr></table></figure><h2 id="新建并切换到新分支上，同时这个分支没有任何-commit"><a href="#新建并切换到新分支上，同时这个分支没有任何-commit" class="headerlink" title="新建并切换到新分支上，同时这个分支没有任何 commit"></a>新建并切换到新分支上，同时这个分支没有任何 commit</h2><p>相当于保存修改，但是重写 commit 历史</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="展示任意分支某一文件的内容"><a href="#展示任意分支某一文件的内容" class="headerlink" title="展示任意分支某一文件的内容"></a>展示任意分支某一文件的内容</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;branch-name&gt;:&lt;file-name&gt;</span><br></pre></td></tr></table></figure><h2 id="clone-下来指定的单一分支"><a href="#clone-下来指定的单一分支" class="headerlink" title="clone 下来指定的单一分支"></a>clone 下来指定的单一分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git</span><br></pre></td></tr></table></figure><h2 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged path/to/file</span><br></pre></td></tr></table></figure><p>恢复 track 指定文件的改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --no-assume-unchanged path/to/file</span><br></pre></td></tr></table></figure><h2 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.fileMode <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="以最后提交的顺序列出所有-Git-分支"><a href="#以最后提交的顺序列出所有-Git-分支" class="headerlink" title="以最后提交的顺序列出所有 Git 分支"></a>以最后提交的顺序列出所有 Git 分支</h2><p>最新的放在最上面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">for</span>-each-ref --sort=-committerdate --format=<span class="string">'%(refname:short)'</span> refs/heads/</span><br></pre></td></tr></table></figure><h2 id="在-commit-log-中查找相关内容"><a href="#在-commit-log-中查找相关内容" class="headerlink" title="在 commit log 中查找相关内容"></a>在 commit log 中查找相关内容</h2><p>通过 grep 查找，given-text：所需要查找的字段</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --grep=<span class="string">'&lt;given-text&gt;'</span></span><br></pre></td></tr></table></figure><h2 id="把暂存区的指定-file-放到工作区中"><a href="#把暂存区的指定-file-放到工作区中" class="headerlink" title="把暂存区的指定 file 放到工作区中"></a>把暂存区的指定 file 放到工作区中</h2><p>不添加参数，默认是 <code>-mixed</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h2 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="一图详解"><a href="#一图详解" class="headerlink" title="一图详解"></a>一图详解</h2><p><img src="../images/post/git.png" alt=""></p><h2 id="优雅的提交Commit信息"><a href="#优雅的提交Commit信息" class="headerlink" title="优雅的提交Commit信息"></a>优雅的提交Commit信息</h2><p>使用<a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines" target="_blank" rel="noopener">Angular团队提交规范</a></p><p>主要有以下组成</p><ul><li>标题行: 必填, 描述主要修改类型和内容</li><li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li><li>页脚注释: 放 Breaking Changes 或 Closed Issues</li></ul><p>常用的修改项</p><ul><li>type: commit 的类型</li><li>feat: 新特性</li><li>fix: 修改问题</li><li>refactor: 代码重构</li><li>docs: 文档修改</li><li>style: 代码格式修改, 注意不是 css 修改</li><li>test: 测试用例修改</li><li>chore: 其他修改, 比如构建流程, 依赖管理.</li><li>scope: commit 影响的范围, 比如: route, component, utils, build…</li><li>subject: commit 的概述</li><li>body: commit 具体修改内容, 可以分为多行</li><li>footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.</li></ul><h3 id="使用Commitizen代替-git-commit"><a href="#使用Commitizen代替-git-commit" class="headerlink" title="使用Commitizen代替 git commit"></a>使用<code>Commitizen</code>代替 git commit</h3><p>可以使用<a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">cz-cli</a>工具代替 <code>git commit</code></p><p>全局安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line"></span><br><span class="line">echo '&#123; "path": "cz-conventional-changelog" &#125;' &gt; ~/.czrc</span><br></pre></td></tr></table></figure><p>全局安装后使用 <code>git cz</code> 代替 <code>git commit</code>就可以了,如下图</p><p><img src="../images/post/gitcz.png" alt=""></p><p><strong><a href="#目录">⬆ 返回顶部</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git的奇技淫巧&quot;&gt;&lt;a href=&quot;#Git的奇技淫巧&quot; class=&quot;headerlink&quot; title=&quot;Git的奇技淫巧:&quot;&gt;&lt;/a&gt;Git的奇技淫巧:&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;Git常用命令集合&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Git是一个 “分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过 “回撤” 这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用 “回撤” 是找不回来的。而 “版本管理工具” 能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。&lt;/p&gt;&lt;p&gt;下面的内容就是列举了常用的 Git 命令和一些小技巧，可以通过 “页面内查找” 的方式进行快速查询：&lt;code&gt;Ctrl/Command+f&lt;/code&gt;。&lt;/p&gt;&lt;h2 id=&quot;开卷必读&quot;&gt;&lt;a href=&quot;#开卷必读&quot; class=&quot;headerlink&quot; title=&quot;开卷必读&quot;&gt;&lt;/a&gt;开卷必读&lt;/h2&gt;&lt;p&gt;&lt;em&gt;如果之前未使用过 Git，可以学习 &lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git 小白教程&lt;/a&gt;入门&lt;/em&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;一定要先测试命令的效果后&lt;/strong&gt;，再用于工作环境中，以防造成不能弥补的后果！&lt;strong&gt;到时候别拿着砍刀来找我&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;所有的命令都在&lt;code&gt;git version 2.7.4 (Apple Git-66)&lt;/code&gt;下测试通过&lt;/li&gt;&lt;li&gt;统一概念：&lt;ul&gt;&lt;li&gt;工作区：改动（增删文件和内容）&lt;/li&gt;&lt;li&gt;暂存区：输入命令：&lt;code&gt;git add 改动的文件名&lt;/code&gt;，此次改动就放到了 ‘暂存区’&lt;/li&gt;&lt;li&gt;本地仓库(简称：本地)：输入命令：&lt;code&gt;git commit 此次修改的描述&lt;/code&gt;，此次改动就放到了 ’本地仓库’，每个 commit，我叫它为一个 ‘版本’。&lt;/li&gt;&lt;li&gt;远程仓库(简称：远程)：输入命令：&lt;code&gt;git push 远程仓库&lt;/code&gt;，此次改动就放到了 ‘远程仓库’（GitHub 等)&lt;/li&gt;&lt;li&gt;commit-id：输出命令：&lt;code&gt;git log&lt;/code&gt;，最上面那行 &lt;code&gt;commit xxxxxx&lt;/code&gt;，后面的字符串就是 commit-id
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="git" scheme="https://ghostsf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>四种软件架构：Serverless架构、微服务架构、分布式架构、单体架构</title>
    <link href="https://ghostsf.com/architectures/"/>
    <id>https://ghostsf.com/architectures/</id>
    <published>2019-04-03T09:44:55.000Z</published>
    <updated>2020-03-08T09:47:34.599Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个软件开发人员，不了解软件架构的演进，会制约技术的选型和开发人员的生存、晋升空间。这里我列举了目前主要的四种软件架构以及他们的优缺点，希望能够帮助软件开发人员拓展知识面。</p><a id="more"></a><p>一、单体架构</p><p>单体架构比较初级，典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层。这是一种典型的Java Spring mvc或者Python Django框架的应用。其架构图如下所示：</p><p><img src="../images/post/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84.jpg" alt="单体架构"></p><p>单体架构的应用比较容易部署、测试， 在项目的初期，单体应用可以很好地运行。然而，随着需求的不断增加， 越来越多的人加入开发团队，代码库也在飞速地膨胀。慢慢地，单体应用变得越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高。下面是单体架构应用的一些缺点：</p><p>复杂性高： 以一个百万行级别的单体应用为例，整个项目包含的模块非常多、模块的边界模糊、 依赖关系不清晰、 代码质量参差不齐、 混乱地堆砌在一起。可想而知整个项目非常复杂。 每次修改代码都心惊胆战， 甚至添加一个简单的功能， 或者修改一个Bug都会带来隐含的缺陷。</p><p>技术债务： 随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务， 并且越积 越多。“ 不坏不修”， 这在软件开发中非常常见， 在单体应用中这种思想更甚。 已使用的系统设计或代码难以被修改，因为应用程序中的其他模块可能会以意料之外的方式使用它。</p><p>部署频率低： 随着代码的增多，构建和部署的时间也会增加。而在单体应用中， 每次功能的变更或缺陷的修复都会导致需要重新部署整个应用。全量部署的方式耗时长、 影响范围大、 风险高， 这使得单体应用项目上线部署的频率较低。 而部署频率低又导致两次发布之间会有大量的功能变更和缺陷修复，出错率比较高。</p><p>可靠性差： 某个应用Bug，例如死循环、内存溢出等， 可能会导致整个应用的崩溃。</p><p>扩展能力受限： 单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩。例如，应用中有的模块是计算密集型的，它需要强劲的CPU； 有的模块则是IO密集型的，需要更大的内存。 由于这些模块部署在一起，不得不在硬件的选择上做出妥协。</p><p>阻碍技术创新： 单体应用往往使用统一的技术平台或方案解决所有的问题， 团队中的每个成员 都必须使用相同的开发语言和框架，要想引入新框架或新技术平台会非常困难。</p><p>二、分布式应用</p><p>中级架构，分布式应用，中间层分布式+数据库分布式，是单体架构的并发扩展，将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，如redis、ES、solor等。通过LVS/Nginx代理应用，将用户请求均衡的负载到不同的服务器上。其架构图如下所示：</p><p><img src="../images/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84.jpg" alt="分布式架构"></p><p>该架构相对于单体架构来说，这种架构提供了负载均衡的能力，大大提高了系统负载能力，解决了网站高并发的需求。另外还有以下特点：</p><p>降低了耦合度：把模块拆分,使用接口通信,降低模块之间的耦合度。</p><p>责任清晰：把项目拆分成若干个子项目,不同的团队负责不同的子项目。</p><p>扩展方便：增加功能时只需要再增加一个子项目,调用其他系统的接口就可以。</p><p>部署方便:可以灵活的进行分布式部署。</p><p>提高代码的复用性：比如service层,如果不采用分布式rest服务方式架构就会在手机wap商城,微信商城,pc,android，ios每个端都要写一个service层逻辑,开发量大,难以维护一起升级,这时候就可以采用分布式rest服务方式,公用一个service层。</p><p>缺点 : 系统之间的交互要使用远程通信,接口开发增大工作量,但是利大于弊。</p><p>三、微服务架构</p><p>微服务架构，主要是中间层分解，将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。当应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用，其代表框架有Spring cloud、Dubbo等。 其架构图如下所示：</p><p><img src="../images/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.jpg" alt="微服务架构"></p><p>易于开发和维护： 一个微服务只会关注一个特定的业务功能，所以它业务清晰、代码量较少。 开发和维护单个微服务相对简单。而整个应用是由若干个微服务构建而成的，所以整个应用也会被维持在一个可控状态。</p><p>单个微服务启动较快： 单个微服务代码量较少， 所以启动会比较快。</p><p>局部修改容易部署： 单体应用只要有修改，就得重新部署整个应用，微服务解决了这样的问题。 一般来说，对某个微服务进行修改，只需要重新部署这个服务即可。</p><p>技术栈不受限：在微服务架构中，可以结合项目业务及团队的特点，合理地选择技术栈。例如某些服务可使用关系型数据库MySQL；某些微服务有图形计算的需求，可以使用Neo4j；甚至可根据需要，部分微服务使用Java开发，部分微服务使用Node.js开发。</p><p>微服务虽然有很多吸引人的地方，但它并不是免费的午餐，使用它是有代价的。使用微服务架构面临的挑战。</p><p>运维要求较高：更多的服务意味着更多的运维投入。在单体架构中，只需要保证一个应用的正常运行。而在微服务中，需要保证几十甚至几百个服务服务的正常运行与协作，这给运维带来了很大的挑战。</p><p>分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都会带来巨大的挑战。</p><p>接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的API，可能所有使用了该接口的微服务都需要做调整。</p><p>重复劳动：很多服务可能都会使用到相同的功能，而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个服务都会开发这一功能，从而导致代码重复。尽管可以使用共享库来解决这个问题（例如可以将这个功能封装成公共组件，需要该功能的微服务引用该组件），但共享库在多语言环境下就不一定行得通了。</p><p>四、Serverless架构</p><p>当我们还在容器的浪潮中前行时，已经有一些革命先驱悄然布局另外一个云计算战场：Serverless架构。</p><p><img src="../images/post/Serverless%E6%9E%B6%E6%9E%84.jpg" alt="Serverless架构"></p><p>2014年11月14日，亚马逊AWS发布了新产品Lambda。当时Lambda被描述为：一种计算服务，根据时间运行用户的代码，无需关心底层的计算资源。从某种意义上来说，Lambda姗姗来迟，它像云计算的PaaS理念：客户只管业务，无需担心存储和计算资源。在此前不久，2014年10月22日，谷歌收购了实时后端数据库创业公司Firebase。Firebase声称开发者只需引用一个API库文件就可以使用标准REST API的各种接口对数据进行读写操作，只需编写HTML＋CSS＋JavaScrip前端代码，不需要服务器端代码（如需整合，也极其简单）。</p><p>相对于上两者，Facebook 在2014年二月收购的 Parse，则侧重于提供一个通用的后台服务。这些服务被称为Serverless或no sever。想到PaaS（平台即服务）了是吗？很像，用户不需要关心基础设施，只需要关心业务，这是迟到的PaaS，也是更实用的PaaS。这很有可能将会变革整个开发过程和传统的应用生命周期，一旦开发者们习惯了这种全自动的云上资源的创建和分配，或许就再也回不到那些需要微应用配置资源的时代里去了。</p><p>Serverless架构能够让开发者在构建应用的过程中无需关注计算资源的获取和运维，由平台来按需分配计算资源并保证应用执行的SLA（服务等级协议），按照调用次数进行计费，有效的节省应用成本。ServerLess的架构如上图所示。其优点如下所示：</p><p>低运营成本：在业务突发性极高的场景下，系统为了应对业务高峰，必须构建能够应对峰值需求的系统，这个系统在大部分时间是空闲的，这就导致了严重的资源浪费和成本上升。在微服务架构中，服务需要一直运行，实际上在高负载情况下每个服务都不止一个实例，这样才能完成高可用性；在Serverless架构下，服务将根据用户的调用次数进行计费，按照云计算pay-as-you-go原则，如果没有东西运行，你就不必付款，节省了使用成本。同时，用户能够通过共享网络、硬盘、CPU等计算资源，在业务高峰期通过弹性扩容方式有效的应对业务峰值，在业务波谷期将资源分享给其他用户，有效的节约了成本。</p><p>简化设备运维：在原有的IT体系中，开发团队即需要维护应用程序，同时还要维护硬件基础设施；Serverless架构中，开发人员面对的将是第三方开发或自定义的API 和URL，底层硬件对于开发人员透明化了，技术团队无需再关注运维工作，能够更加专注于应用系统开发。</p><p>提升可维护性：Serverless架构中，应用程序将调用多种第三方功能服务，组成最终的应用逻辑。目前，例如登陆鉴权服务，云数据库服务等第三方服务在安全性、可用性、性能方面都进行了大量优化，开发团队直接集成第三方的服务，能够有效的降低开发成本，同时使得应用的运维过程变得更加清晰，有效的提升了应用的可维护性。</p><p>更快的开发速度：这一点在现在互联网创业公司得到很好的体现，创业公司往往开始由于人员和资金等问题，不可能每个产品线都同时进行，这时候就可以考虑第三方的Baas平台，比如使用微信的用户认证、阿里云提供的RDS，极光的消息推送，第三方支付及地理位置等等，能够很快进行产品开发的速度，把工作重点放在业务实现上，把产品更快的推向市场。</p><p>但ServerLess架构也有其缺点：</p><p>厂商平台绑定：平台会提供Serverless架构给大玩家，比如AWS Lambda，运行它需要使用AWS指定的服务，比如API网关，DynamoDB，S3等等，一旦你在这些服务上开发一个复杂系统，你会粘牢AWS，以后只好任由他们涨价定价或者下架等操作，个性化需求很难满足，不能进行随意的迁移或者迁移的成本比较大，同时不可避免带来一些损失。Baas行业内一个比较典型的事件，2016年1月19日Facebook关闭曾经花巨额资金收购的Parse，造成用户不得不迁移在这个平台中产生一年多的数据，无疑需要花费比较大的人力和时间成本。</p><p>成功案例比较少，没有行业标准：目前的情况也只适合简单的应用开发，缺乏大型成功案例的推动。对于Serverless缺乏统一的认知以及相应的标准，无法适应所有的云平台。</p><p>目前微服务架构在四种架构中处于主流地位，很多应用第一、第二种架构的企业也开始慢慢转向微服务架构。到目前为止微服务的技术相对于二三年前已经比较成熟，第四种架构将是未来发展的一种趋势。如果你喜欢我的文章，欢迎关注我的简书，后续我将教会大家利用spring cloud和docker轻松愉快的构建微服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果一个软件开发人员，不了解软件架构的演进，会制约技术的选型和开发人员的生存、晋升空间。这里我列举了目前主要的四种软件架构以及他们的优缺点，希望能够帮助软件开发人员拓展知识面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="架构" scheme="https://ghostsf.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
